<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Aaron A. King" />

<meta name="date" content="2022-07-07" />

<title>pomp C API</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>







<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>


<a name="top"></a>


<h1 class="title toc-ignore">pomp C API</h1>
<h4 class="author">Aaron A. King</h4>
<h4 class="date">7 July 2022</h4>


<div id="TOC">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#random-variables">Random variables</a><ul>
<li><a href="#beta-binomial-distribution">Beta-binomial distribution</a></li>
<li><a href="#multinomial-distribution">Multinomial distribution</a></li>
<li><a href="#euler-multinomial-distribution">Euler-multinomial distribution</a></li>
<li><a href="#gamma-white-noise">Gamma white noise</a></li>
</ul></li>
<li><a href="#splines">Splines</a></li>
<li><a href="#transformations">Transformations</a><ul>
<li><a href="#logit-transformation">Logit transformation</a></li>
<li><a href="#log-barycentric-transformation">Log-barycentric transformation</a></li>
</ul></li>
<li><a href="#convenience-functions">Convenience functions</a><ul>
<li><a href="#vector-dot-product">Vector dot product</a></li>
<li><a href="#exponentialgeometric-rate-conversion">Exponential/geometric rate conversion</a></li>
</ul></li>
<li><a href="#access-to-the-userdata">Access to the userdata</a></li>
<li><a href="#prototypes-for-basic-model-components">Prototypes for basic model components</a><ul>
<li><a href="#indices">Indices</a></li>
<li><a href="#rinit">rinit</a></li>
<li><a href="#rprocess">rprocess</a></li>
<li><a href="#dprocess">dprocess</a></li>
<li><a href="#skeleton">skeleton</a></li>
<li><a href="#rmeasure">rmeasure</a></li>
<li><a href="#dmeasure">dmeasure</a></li>
<li><a href="#emeasure">emeasure</a></li>
<li><a href="#vmeasure">vmeasure</a></li>
<li><a href="#rprior">rprior</a></li>
<li><a href="#dprior">dprior</a></li>
<li><a href="#partrans">partrans</a></li>
</ul></li>
</ul>
</div>

<style type="text/css">
a:link, a:visited {
  color: #0000ff;
  text-decoration: none;
}
a:hover, a:active {
  color: #cc3333;
  text-decoration: none;
}
code {
  font-size: 110%;
}
</style>
<hr />
<div id="overview" class="section level2">
<h2>Overview</h2>
<p><strong>pomp</strong> provides C entry points to a number of facilities for model specification. Below, we describe these, providing the prototypical function calls and descriptions of their arguments.</p>
<p>The <a href="#prototypes-for-basic-model-components">final section</a> describes the prototypes for the basic model components. Users wishing to write libraries to hold basic model components must furnish functions of these prototypes that perform the basic model component computations.</p>
</div>
<div id="random-variables" class="section level2">
<h2>Random variables</h2>
<div id="beta-binomial-distribution" class="section level3">
<h3>Beta-binomial distribution</h3>
<pre><code>double rbetabinom(double size, double prob, double theta);
double dbetabinom(double x, double size, double prob, 
    double theta, int give_log);</code></pre>
<p><span class="math inline">\(X\)</span> is said to be Beta-binomially distributed with size <span class="math inline">\(n\)</span>, mean probability <span class="math inline">\(p\)</span>, and dispersion parameter <span class="math inline">\(\theta\)</span> if <span class="math display">\[P \sim \mathrm{Beta}\left(\theta\,p,\theta\,(1-p)\right)\]</span> and <span class="math display">\[X|P \sim \mathrm{Binomial}\left(n,P\right).\]</span> If <span class="math inline">\(X\sim\mathrm{BetaBinomial}\left(n,p,\theta\right)\)</span>, then <span class="math display">\[\mathbb{E}\left[X\right]=n\,p\qquad\text{and}\qquad\mathrm{Var}\left[X\right]=n\,p\,(1-p)\,\frac{\theta+n}{\theta+1}.\]</span></p>
</div>
<div id="multinomial-distribution" class="section level3">
<h3>Multinomial distribution</h3>
<pre><code>double dmultinom(int m, const double *prob, double *x, int give_log);</code></pre>
<p>The <strong>R</strong> C API provides a simulator for the multinomial distribution, <code>rmultinom</code>. See the “Rmath.h” header file for information on this facility. <strong>pomp</strong> provides an evaluator for the probability mass function (<code>dmultinom</code>) for this distribution.</p>
<p>Input:</p>
<ul>
<li><code>m</code> is a positive integer, is the dimension of the random variable.</li>
<li><code>prob</code> is a pointer to an <code>m</code>-vector of probabilities.</li>
<li><code>x</code> is a pointer to an <code>m</code>-vector containing the data.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if the log probability is desired.</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
</ul>
<p>The return value is the probability or log probability (as requested).</p>
</div>
<div id="euler-multinomial-distribution" class="section level3">
<h3>Euler-multinomial distribution</h3>
<div id="simulate-euler-multinomial-transitions" class="section level4">
<h4>Simulate Euler-multinomial transitions</h4>
<pre><code>void reulermultinom(int m, double size, const double *rate,
  double dt, double *trans);</code></pre>
<p>Input:</p>
<ul>
<li><code>m</code>, a positive integer, is number of potential transitions (“deaths”).</li>
<li><code>size</code>, a positive integer, is the number of individuals at risk.</li>
<li><code>rate</code> is a pointer to the vector of transition (“death”) rates.</li>
<li><code>dt</code>, a positive real number, is the duration of time interval.</li>
<li><code>trans</code> is a pointer to the vector that will hold the random deviate.</li>
</ul>
<p>On return, <code>trans[0]</code>, …, <code>trans[m-1]</code> will be the numbers of individuals making each of the respective transitions.</p>
<p>See <code>?reulermultinom</code>, <a href="https://kingaa.github.io/pomp/FAQ.html#eulermultinomial-approximation">FAQ 3.6</a>, and the package vignettes for more on the Euler-multinomial distributions.</p>
<p><strong>NB:</strong> <code>reulermultinom</code> does not call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> internally. This must be done by the calling program. But note that when <code>reulermultinom</code> is called inside a <strong>pomp</strong> rprocess, there is no need to call either <code>GetRNGState()</code> or <code>PutRNGState()</code>; this is handled by <strong>pomp</strong>.</p>
</div>
<div id="compute-probabilities-of-euler-multinomial-transitions" class="section level4">
<h4>Compute probabilities of Euler-multinomial transitions</h4>
<pre><code>double deulermultinom(int m, double size, const double *rate,
  double dt, double *trans, int give_log);</code></pre>
<p>Input:</p>
<ul>
<li><code>m</code>, a positive integer, is the number of potential transitions (“deaths”).</li>
<li><code>size</code>, a positive integer, is the number of individuals at risk.</li>
<li><code>rate</code> is a pointer to vector of transition (“death”) rates.</li>
<li><code>dt</code>, a positive real number, is the duration of time interval.</li>
<li><code>trans</code> is pointer to vector containing the data, which are numbers of individuals making the respective transitions.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if log probability is desired;</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
</ul>
<p>The value returned is the probability or log probability (as requested).</p>
<p>See <code>?deulermultinom</code>, <a href="https://kingaa.github.io/pomp/FAQ.html#eulermultinomial-approximation">FAQ 3.6</a>, and the package vignettes for more on the Euler-multinomial distributions.</p>
</div>
</div>
<div id="gamma-white-noise" class="section level3">
<h3>Gamma white noise</h3>
<pre><code>double rgammawn(double sigma, double dt);</code></pre>
<p>Corresponding to the <strong>R</strong> function <code>rgammawn</code>, this C function draws a single random increment of a gamma white-noise process. This will have expectation equal to <code>dt</code> and variance <code>sigma^2*dt</code>.</p>
<p>In particular, when <code>dW = rgammawn(sigma,dt);</code> is executed, <code>mu*dW/dt</code> is a candidate for a random rate process within an Euler-multinomial context, i.e., <code>mu*dW</code> will have expectation <code>mu*dt</code> and variance <code>mu*sigma^2*dt</code>.</p>
</div>
</div>
<div id="splines" class="section level2">
<h2>Splines</h2>
<pre><code>void periodic_bspline_basis_eval(double x, double period, int degree, 
    int nbasis, double *y);
void periodic_bspline_basis_eval_deriv(double x, double period, 
    int degree, int nbasis, int deriv, double *y);</code></pre>
<p>These functions work with periodic B-spline basis functions. The period and smoothness of the functions are given by <code>period</code> and <code>degree</code>, respectively. The first function evaluates <code>nbasis</code> periodic B-spline basis functions at <code>x</code>. The second evaluates the order-<code>deriv</code> derivative of each basis function.</p>
</div>
<div id="transformations" class="section level2">
<h2>Transformations</h2>
<div id="logit-transformation" class="section level3">
<h3>Logit transformation</h3>
<pre><code>double logit(double p);
double expit(double x);</code></pre>
<p>The logit transformation is defined by <span class="math display">\[x = \log\frac{p}{1-p}.\]</span> Its inverse is therefore <span class="math display">\[p = \frac{1}{1+e^{-x}}.\]</span></p>
</div>
<div id="log-barycentric-transformation" class="section level3">
<h3>Log-barycentric transformation</h3>
<pre><code>void to_log_barycentric(double *xt, const double *x, int n);
void from_log_barycentric(double *xt, const double *x, int n);</code></pre>
<p>The log-barycentric transformation takes a vector <span class="math inline">\(X_i\in\mathbb{R}^n_+\)</span>, <span class="math inline">\(i=1,\dots,n\)</span>, to a vector <span class="math inline">\(Y_i\in\mathbb{R}^n\)</span>, where <span class="math display">\[Y_i = \log\frac{X_i}{\sum_j\!X_j}.\]</span> The log-barycentric transformation takes every simplex defined by <span class="math inline">\(\sum_i\!X_i = c\)</span>, <span class="math inline">\(c\)</span> constant, to <span class="math inline">\(n\)</span>-dimensional Euclidean space <span class="math inline">\(\mathbb{R}^n\)</span>.</p>
<p>The pseudo-inverse transformation takes <span class="math inline">\(\mathbb{R}^n\)</span> to the unit simplex <span class="math inline">\(S=\{X\in\mathbb{R}^n_+\;\vert\;\sum_i\!X_i=1\}\)</span>. Specifically, <span class="math display">\[X_i = \frac{e^{Y_i}}{\sum_j\!e^{Y_j}}.\]</span></p>
<p>Note that if <span class="math inline">\(T:\mathbb{R}^n_+\to\mathbb{R}^n\)</span> is the log-barycentric transformation so defined, <span class="math inline">\(U\)</span> is the pseudo-inverse, and <span class="math inline">\(Id\)</span> denotes the identity map, then <span class="math inline">\(T\circ U=Id:\mathbb{R}^n\to\mathbb{R}^n\)</span> but <span class="math inline">\(U\circ T\ne Id\)</span>. However, if <span class="math inline">\(T\)</span> is restricted to the unit simplex, then <span class="math inline">\(U\circ T=Id:S\to S\)</span>.</p>
<p>Input:</p>
<ul>
<li><code>x</code> is a pointer to vector of parameters to be tranformed either to or from to log barycentric coordinates.</li>
<li><code>n</code> is the length of this vector.</li>
<li><code>xt</code> is a pointer to the vector that will hold the results.</li>
</ul>
<p>On return, <code>xt[0]</code>, …, <code>xt[n-1]</code> will contain the transformed coordinates.</p>
</div>
</div>
<div id="convenience-functions" class="section level2">
<h2>Convenience functions</h2>
<div id="vector-dot-product" class="section level3">
<h3>Vector dot product</h3>
<pre><code>double dot_product(int n, const double *x, const double *y);</code></pre>
<p>The return value is the dot (inner) product of the <code>n</code>-vectors <code>x</code> and <code>y</code>. By definition, <span class="math display">\[x{\cdot}y = \sum_i\!x_i\,y_i.\]</span></p>
</div>
<div id="exponentialgeometric-rate-conversion" class="section level3">
<h3>Exponential/geometric rate conversion</h3>
<pre><code>double exp2geom_rate_correction(double R, double dt);</code></pre>
<p>This function computes <span class="math inline">\(r\)</span> such that if <span class="math display">\[N \sim \mathrm{Geometric}\left(p=1-e^{-r\,{\Delta}t}\right)\]</span> and <span class="math display">\[T \sim \mathrm{Exponential}\left(\mathrm{rate}=R\right),\]</span> then <span class="math inline">\(\mathbb{E}\left[N\,{\Delta}t\right] = \mathbb{E}\left[T\right]\)</span>. That is, <span class="math inline">\(r\)</span> is the rate for an Euler process that gives the same expected waiting time as the exponential process it approximates. In particular <span class="math inline">\(r \to R\)</span> as <span class="math inline">\({\Delta}t \to 0\)</span>.</p>
</div>
</div>
<div id="access-to-the-userdata" class="section level2">
<h2>Access to the userdata</h2>
<pre><code>const int *get_userdata_int(const char *name);
const double *get_userdata_double(const char *name);
const SEXP get_userdata(const char *name);</code></pre>
<p>The first function returns a pointer to the integer element of the <code>userdata</code> with the given <code>name</code>. The second retrieves a pointer to a double-precision element of <code>userdata</code> by name. The third form returns a general S expression (<code>SEXP</code>). See <code>?userdata</code> for more information.</p>
</div>
<div id="prototypes-for-basic-model-components" class="section level2">
<h2>Prototypes for basic model components</h2>
<p><strong>pomp</strong> provides a facility whereby model codes can be compiled into a dynamically linked library for use in pomp objects. Specifically, basic model components are coded as C functions with the following prototypes.</p>
<p><strong>NB:</strong> These functions should not be used within C snippets!</p>
<div id="indices" class="section level3">
<h3>Indices</h3>
<p>Each of the following functions is supplied one or more of the <code>stateindex</code>, <code>parindex</code>, <code>covindex</code>, <code>obsindex</code>, <code>vmatindex</code> arguments. Each of these is an integer vector: the integers within are indices giving the positions of specific model variables, according to the user’s specification, the latter being given by means of the <code>statenames</code>, <code>paramnames</code>, <code>covarnames</code>, and <code>obsnames</code> arguments. See <code>?pomp</code> for more explanation. Thus, for example, within the body of a function of prototype <code>pomp_rinit</code> (see below),</p>
<pre><code> x[stateindex[0]];
 x[stateindex[3]];
 p[parindex[2]];
 covars[covindex[1]];</code></pre>
<p>refer to the first state variable, the fourth state variable, the third parameter, and the second covariate, respectively.</p>
</div>
<div id="rinit" class="section level3">
<h3>rinit</h3>
<pre><code>void pomp_rinit(double *x, const double *p, double t,
  const int *stateindex, const int *parindex, const int *covindex,
  const double *covars);</code></pre>
<p>Description:</p>
<ul>
<li><code>p</code> is a pointer to parameter vector.</li>
<li><code>t</code> is the current time.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is a pointer to a vector containing the (possibly interpolated) values of the covariates at the current time.</li>
<li><code>x</code> is a vector that will, on return, contain a draw from the initial-state distribution.</li>
</ul>
<p><strong>NB:</strong> There is no need to call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="rprocess" class="section level3">
<h3>rprocess</h3>
<div id="step.fun-as-used-by-euler-and-onestep" class="section level4">
<h4><code>step.fun</code> as used by <code>euler</code> and <code>onestep</code></h4>
<pre><code>void pomp_onestep_sim(double *x, const double *p,
  const int *stateindex, const int *parindex, const int *covindex,
  const double *covars, double t, double dt);</code></pre>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of covariates.</li>
<li><code>t</code> is the time at the beginning of the step.</li>
<li><code>dt</code> is the step size (duration of the interval).</li>
<li><code>x</code> is the vector, that will, on return, contain a draw from the state process at time <code>t</code>+<code>dt</code>.</li>
</ul>
<p><strong>NB:</strong> There is no need to call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="rate.fun-as-used-by-gillespie" class="section level4">
<h4><code>rate.fun</code> as used by <code>gillespie</code></h4>
<pre><code>double pomp_ssa_rate_fn(int event, 
    double t, const double *x, const double *p,
    const int *stateindex, const int *parindex, const int *covindex, 
    const double *covars);</code></pre>
<p>Description:</p>
<ul>
<li><code>event</code> is an integer specifying the number of the reaction whose rate is desired (the first is event is 1, not 0).</li>
<li><code>t</code> is the current time.</li>
<li><code>x</code> is the vector of state variables.</li>
<li><code>p</code> is the vector of parameters.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
</ul>
<p>The function returns the rate of the requested reaction.</p>
</div>
</div>
<div id="dprocess" class="section level3">
<h3>dprocess</h3>
<pre><code>void pomp_onestep_pdf(double *loglik,
  const double *x1, const double *x2, double t1, double t2, const double *p,
  const int *stateindex, const int *parindex, const int *covindex,
  const double *covars);</code></pre>
<p>Description:</p>
<ul>
<li><code>t1</code>, <code>t2</code> are the times at the beginning and end of the interval, respectively.</li>
<li><code>x1</code>, <code>x2</code> are the state vectors at time <code>t1</code> and <code>t2</code>, respectively.</li>
<li><code>p</code> is the parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>loglik</code> is a pointer to the scalar that will, on return, contain the log probability density.</li>
</ul>
</div>
<div id="skeleton" class="section level3">
<h3>skeleton</h3>
<pre><code>void pomp_skeleton(double *f, const double *x, const double *p,
  const int *stateindex, const int *parindex, const int *covindex,
  const double *covars, double t);</code></pre>
<p>Description:</p>
<ul>
<li><code>t</code> is the time.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>f</code> is a vector, of the same length as <code>x</code>, that will, on return, contain the value of the map or vectorfield.</li>
</ul>
</div>
<div id="rmeasure" class="section level3">
<h3>rmeasure</h3>
<pre><code>void pomp_measure_model_simulator(double *y, 
    const double *x, const double *p,
    const int *obsindex, const int *stateindex, const int *parindex, const int *covindex,
    const double *covars, double t);</code></pre>
<p>Description:</p>
<ul>
<li><code>t</code> is the time at the beginning of the Euler step.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter vector.</li>
<li><code>obsindex</code>, <code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>y</code> is a vector that will, on return, contain the simulated observations.</li>
</ul>
<p><strong>NB:</strong> There is no need to call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="dmeasure" class="section level3">
<h3>dmeasure</h3>
<pre><code>void pomp_measure_model_density(double *lik, 
    const double *y, const double *x, const double *p, int give_log,
    const int *obsindex, const int *stateindex, const int *parindex, const int *covindex,
    const double *covars, double t);</code></pre>
<p>Description:</p>
<ul>
<li><code>y</code> is the vector of observables at time <code>t</code>.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter vector.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if log probability is desired;</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
<li><code>obsindex</code>, <code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>lik</code> is a pointer to a scalar that will, on return, contain the requested likelihood or log likelihood.</li>
</ul>
</div>
<div id="emeasure" class="section level3">
<h3>emeasure</h3>
<pre><code>void pomp_emeasure (double *e, const double *x, const double *p,
  const int *obsindex, const int *stateindex, const int *parindex, const int *covindex,
  const double *covars, double t);</code></pre>
<p>Description:</p>
<ul>
<li><code>t</code> is the time.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>e</code> is a vector, of the same length as <code>x</code>, that will, on return, contain the expected value of the observed variables.</li>
</ul>
</div>
<div id="vmeasure" class="section level3">
<h3>vmeasure</h3>
<pre><code>void pomp_vmeasure (double *v, const double *x, const double *p,
  const int *vmatindex, 
  const int *stateindex, const int *parindex, const int *covindex,
  const double *covars, double t);</code></pre>
<p>Description:</p>
<ul>
<li><code>t</code> is the time.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>, <code>vmatindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>v</code> points to a square matrix that will, on return, contain the covariance matrix of the observed variables. In particular, if <span class="math inline">\(X\)</span> is the latent state and the <code>nobs</code> observables are <span class="math inline">\(Y_i\)</span>, then <code>v[vmatindex[i+nobs*j]]</code> contains <span class="math inline">\(\mathrm{Cov}[Y_i,Y_j\;\vert\;X]\)</span>.</li>
<li>It is the user’s responsibility to ensure that the returned covariance matrix is symmetric: this is not checked.</li>
</ul>
</div>
<div id="rprior" class="section level3">
<h3>rprior</h3>
<pre><code>void pomp_rprior(double *p, const int *parindex);</code></pre>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>parindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
</ul>
<p>On return, <code>p</code> will contain a new random draw from the prior distribution.</p>
<p><strong>NB:</strong> There is no need to call GetRNGstate() or PutRNGstate() in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="dprior" class="section level3">
<h3>dprior</h3>
<pre><code>void pomp_dprior(double *lik, const double *p, int give_log, const int *parindex);</code></pre>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if log probability is desired;</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
<li><code>parindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>lik</code> is a pointer to a scalar that will, on return, contain the requested probability density or log probability density.</li>
</ul>
</div>
<div id="partrans" class="section level3">
<h3>partrans</h3>
<pre><code>void pomp_transform_fn(double *pt, const double *p, const int *parindex);</code></pre>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>parindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>pt</code> is the vector wherein the results will be returned.</li>
</ul>
<hr />
<p>This document was produced using <strong>pomp</strong> version 4.2.3.0 and <strong>R</strong> version 4.2.1.</p>
</div>
</div>

<a href="#top">Top of this document</a><br />
<a href="https://kingaa.github.io/pomp/docs.html"><strong>pomp</strong> documentation index</a><br />
<a href="https://kingaa.github.io/manuals/pomp/"><strong>pomp</strong> manual</a><br />
<a href="https://kingaa.github.io/pomp/"><strong>pomp</strong> homepage</a></p>


<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
