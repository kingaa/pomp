---
title: 'Coding POMP models: R vs C snippets'
output: 
  html_document:
    theme: null
    highlight: kate
    toc: yes
    toc_depth: 3
---

```{css echo=FALSE,purl=FALSE}
a:link, a:visited {
  color: #0000ff;
  text-decoration: none;
}
a:hover, a:active {
  color: #cc3333;
  text-decoration: none;
}
code {
  font-size: 110%;
}
```

```{r knitr-opts,include=FALSE,purl=FALSE,cache=FALSE}
params <- list(prefix="R_v_C")
source("setup.R", local = knitr::knit_global())
```

The **R** codes in this script are `r xfun::embed_file("R_v_C.R",text="available for download")`.
This work is licensed under the [Creative Commons attribution-noncommercial license](http://creativecommons.org/licenses/by-nc/3.0).
Please share and remix noncommercially, mentioning its origin.  
![CC-BY_NC](https://kingaa.github.io/images/cc-by-nc.png)

--------------------------------------------------------

To implement models in **pomp**, we have various options.
While it is very easy to code basic model components using **R** functions, it can be much faster to do it using C snippets.
Here, we'll demonstrate both approaches.

First, we'll load some packages.

```{r packages}
library(pomp)
library(ggplot2)
library(tidyr)
```

```{r seed,echo=FALSE}
set.seed(56300069)
```

The Gompertz model is a very simple partially observed Markov process (POMP) model that we'll use to demonstrate.

The latent state variable, $X$ represents the density of a population of biological organisms.
The state equation is
$$X_{t+\delta} = K^{1-S}\,X_{t}^S\,\epsilon_{t},$$
where $S=e^{-r\,\delta}$ is a parameter and the $\epsilon_t$ are i.i.d. lognormal random deviates with variance $\sigma^2$:
$$\epsilon_t \sim \mathrm{Lognormal}(0,\sigma).$$
The observed variables $Y_t$ are lognormally distributed:
$$Y_t \sim\mathrm{Lognormal}(\log{X_t},\tau).$$

## Implementation using **R** functions

To begin with, we'll code the latent state process model and both components of the measurement model using **R** functions.

```{r R1}
simulate(times=1:100,t0=0,
  params=c(K=1,r=0.1,sigma=0.1,tau=0.1,X.0=1),
  rprocess=discrete_time(
    step.fun=function (X,r,K,sigma,...,delta.t) {
      eps <- exp(rnorm(n=1,mean=0,sd=sigma))
      S <- exp(-r*delta.t)
      c(X=K^(1-S)*X^S*eps)
    },
    delta.t=1 
  ),
  rmeasure=function (X, tau, ...) {
    c(Y=rlnorm(n=1,meanlog=log(X),sdlog=tau))
  },
  dmeasure=function (tau, X, Y, ..., log) {
    dlnorm(x=Y,meanlog=log(X),sdlog=tau,log=log)
  }
) -> gompertz
```

We plot the results.

```{r R2}
gompertz |>
  as.data.frame() |>
  pivot_longer(c(X,Y)) |>
  ggplot(aes(x=time,y=value,color=name))+
  geom_line()+
  labs(y="X, Y")+
  theme_bw()
```


## Implementation using C snippets

Now we'll code up the same example using C snippets.

```{r C1}
simulate(
  times=0:100,t0=0,
  params=c(K=1,r=0.1,sigma=0.1,tau=0.1,X.0=1),
  dmeasure=Csnippet("
    lik = dlnorm(Y,log(X),tau,give_log);"
  ),
  rmeasure=Csnippet("
    Y = rlnorm(log(X),tau);"
  ),
  rprocess=discrete_time(
    step.fun=Csnippet("
    double S = exp(-r*dt);
    double logeps = (sigma > 0.0) ? rnorm(0,sigma) : 0.0;
    X = pow(K,(1-S))*pow(X,S)*exp(logeps);"
    ),
    delta.t=1
  ),
  paramnames=c("r","K","sigma","tau"),
  obsnames="Y",
  statenames="X"
) -> Gompertz
```

## Testing the implementations

Having coded the model, it's a good idea to run some simple tests to check the implementation.
We can run simulations and a particle filter operation to check that the *rprocess*, *rmeasure*, and *dmeasure* components function without error.

First, some simulations, from several initial conditions:
```{r params}
Gompertz |>
  coef() |>
  parmat(4) -> p
p["X.0",] <- c(0.5,0.9,1.1,1.5)
```

```{r sim1}
Gompertz |>
  simulate(params=p,format="data.frame") |>
  ggplot(aes(x=time,y=X,group=.id,color=.id))+
  geom_line()+
  guides(color="none")+
  theme_bw()+
  labs(title="Gompertz model",subtitle="stochastic simulations")
```

We run 10 replicate particle filter operations at the true parameter values as follows.
This allows us to assess the Monte Carlo error in the likelihood estimate.

```{r pf1}
Gompertz |>
  pfilter(Np=500) |>
  replicate(n=10) -> pf

logmeanexp(sapply(pf,logLik),se=TRUE,ess=TRUE)
```

## Comparing the implementations

Using each implementation, we'll now run a number of simulations and compare the amount of time required.

```{r comparison,cache=TRUE}
system.time(simulate(gompertz,nsim=10000,format="arrays"))
system.time(simulate(Gompertz,nsim=10000,format="arrays"))
system.time(pfilter(gompertz,Np=10000))
system.time(pfilter(Gompertz,Np=10000))
```

-----------------------------------

This document was produced using **pomp** version `r packageVersion("pomp")` and **R** version `r getRversion()`.

