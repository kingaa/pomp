<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>version 2 upgrade guide</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } 
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.at { color: #204a87; } 
code span.bn { color: #0000cf; } 
code span.cf { color: #204a87; font-weight: bold; } 
code span.ch { color: #4e9a06; } 
code span.cn { color: #8f5902; } 
code span.co { color: #8f5902; font-style: italic; } 
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.dt { color: #204a87; } 
code span.dv { color: #0000cf; } 
code span.er { color: #a40000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #0000cf; } 
code span.fu { color: #204a87; font-weight: bold; } 
code span.im { } 
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.kw { color: #204a87; font-weight: bold; } 
code span.op { color: #ce5c00; font-weight: bold; } 
code span.ot { color: #8f5902; } 
code span.pp { color: #8f5902; font-style: italic; } 
code span.sc { color: #ce5c00; font-weight: bold; } 
code span.ss { color: #4e9a06; } 
code span.st { color: #4e9a06; } 
code span.va { color: #000000; } 
code span.vs { color: #4e9a06; } 
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>








</head>

<body>




<h1 class="title toc-ignore">version 2 upgrade guide</h1>


<div id="TOC">
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#terminology" id="toc-terminology">Terminology</a></li>
<li><a href="#changes-in-the-way-models-are-specified" id="toc-changes-in-the-way-models-are-specified">Changes in the way
models are specified</a>
<ul>
<li><a href="#basic-component-specification" id="toc-basic-component-specification">Basic component
specification</a></li>
<li><a href="#process-model-specification" id="toc-process-model-specification">Process model
specification</a></li>
<li><a href="#initialization-of-the-latent-state-process" id="toc-initialization-of-the-latent-state-process">Initialization of
the latent state process</a></li>
</ul></li>
<li><a href="#covariates" id="toc-covariates">Covariates</a></li>
<li><a href="#parameter-transformations" id="toc-parameter-transformations">Parameter transformations</a></li>
<li><a href="#accumulator-variables" id="toc-accumulator-variables">Accumulator variables</a></li>
<li><a href="#changes-in-elementary-pomp-algorithms" id="toc-changes-in-elementary-pomp-algorithms">Changes in elementary
POMP algorithms</a>
<ul>
<li><a href="#simulate" id="toc-simulate"><code>simulate</code></a></li>
<li><a href="#pfilter-and-bsmc2" id="toc-pfilter-and-bsmc2"><code>pfilter</code> and
<code>bsmc2</code></a></li>
</ul></li>
<li><a href="#change-in-pomp-estimation-algorithms" id="toc-change-in-pomp-estimation-algorithms">Change in
<strong>pomp</strong> estimation algorithms</a>
<ul>
<li><a href="#parameter-transformations-in-estimation" id="toc-parameter-transformations-in-estimation">Parameter
transformations in estimation</a></li>
<li><a href="#mif2-defaults" id="toc-mif2-defaults"><code>mif2</code>
defaults</a></li>
<li><a href="#params-not-start" id="toc-params-not-start"><code>params</code> not
<code>start</code></a></li>
<li><a href="#changes-in-optimization-based-methods-probe-matching-spectrum-matching-trajectory-matching-nonlinear-forecasting" id="toc-changes-in-optimization-based-methods-probe-matching-spectrum-matching-trajectory-matching-nonlinear-forecasting">Changes
in optimization-based methods: probe matching, spectrum matching,
trajectory matching, nonlinear forecasting</a></li>
</ul></li>
<li><a href="#changes-in-pomp-workhorses" id="toc-changes-in-pomp-workhorses">Changes in <strong>pomp</strong>
workhorses</a>
<ul>
<li><a href="#default-model-components" id="toc-default-model-components">Default model components</a></li>
<li><a href="#skeleton" id="toc-skeleton"><code>skeleton</code></a></li>
<li><a href="#trajectory" id="toc-trajectory"><code>trajectory</code></a></li>
<li><a href="#flow" id="toc-flow"><code>flow</code></a></li>
<li><a href="#rprocess" id="toc-rprocess"><code>rprocess</code></a></li>
</ul></li>
<li><a href="#included-pomp-examples" id="toc-included-pomp-examples">Included <strong>pomp</strong>
examples</a></li>
<li><a href="#included-datasets" id="toc-included-datasets">Included
datasets</a></li>
<li><a href="#facilities-removed-in-version-2" id="toc-facilities-removed-in-version-2">Facilities removed in version
2</a></li>
<li><a href="#recoding-your-models-for-pomp-version-2-examples" id="toc-recoding-your-models-for-pomp-version-2-examples">Recoding your
models for <strong>pomp</strong> version 2: examples</a>
<ul>
<li><a href="#gompertz-model" id="toc-gompertz-model">Gompertz
model</a></li>
<li><a href="#sir-model" id="toc-sir-model">SIR model</a></li>
</ul></li>
</ul>
</div>

<hr />
<div id="overview" class="section level2">
<h2>Overview</h2>
<p>In <strong>pomp</strong> version 2, a number of backward incompatible
changes have been made. These have been designed to increase the
usability of the package by making the interfaces more uniform, by
increasing code stability, reducing the number of special cases, and
removing many of the idiosyncrasies that were present in earlier
versions. The goal has been to keep backward-incompatible changes to a
minimum. However, to achieve some improvements, it has been necessary to
make some that will break existing code. This guide is intended to
explain the new structure and point out the changes that are needed to
make existing codes that use <strong>pomp</strong> work with the new
version.</p>
<p>The main novelty of <strong>pomp</strong> version 2 is that one will
rarely, if ever, need to interact directly with the low-level
<code>pomp</code> constructor. Instead, one can supply new or modify
existing model components at (almost) any stage in a chain of
<strong>pomp</strong> computations. In particular, there are now
data-frame methods for all of the <strong>pomp</strong> inference
algorithms, as well as for the so-called <em>elementary POMP
algorithms</em>: <code>simulate</code>, <code>pfilter</code>,
<code>probe</code>, and <code>spect</code>. One can pass data directly
to these methods, along with the requisite model components, and achieve
the same effect as one would by first constructing a object and then
performing the operation.</p>
<p><strong>pomp</strong> version 2 represents a thorough reworking of
almost all the package codes. A consequence is that these codes have
been streamlined, with increases in flexibility and ease of use, at no
cost to performance. The following table shows the number of lines in
the latest pre-2 <strong>pomp</strong> compared to the current
<strong>pomp</strong> version 2.</p>
<table>
<thead>
<tr class="header">
<th align="left">category</th>
<th align="right">1.19</th>
<th align="right">2.5</th>
<th align="right">fraction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">R</td>
<td align="right">12150</td>
<td align="right">9847</td>
<td align="right">-0.190</td>
</tr>
<tr class="even">
<td align="left">man</td>
<td align="right">4069</td>
<td align="right">6908</td>
<td align="right">0.698</td>
</tr>
<tr class="odd">
<td align="left">src</td>
<td align="right">5238</td>
<td align="right">5567</td>
<td align="right">0.063</td>
</tr>
<tr class="even">
<td align="left">tests</td>
<td align="right">4846</td>
<td align="right">3677</td>
<td align="right">-0.241</td>
</tr>
<tr class="odd">
<td align="left">total</td>
<td align="right">26303</td>
<td align="right">25999</td>
<td align="right">-0.012</td>
</tr>
</tbody>
</table>
</div>
<div id="terminology" class="section level2">
<h2>Terminology</h2>
<p>It is useful to divide the <strong>pomp</strong> package
functionality into different levels.</p>
<ul>
<li><em>Basic model components</em>: user-specified procedures that
perform the elementary computations that specify a POMP model. There are
nine of these:
<ul>
<li><code>rinit</code>: simulator for the initial-state distribution,
i.e., the distribution of the latent state at time <code>t0</code>.</li>
<li><code>rprocess</code> and <code>dprocess</code>: simulator and
density evaluation procedure, respectively, for the process model.</li>
<li><code>rmeasure</code> and <code>dmeasure</code>: simulator and
density evaluation procedure, respectively, for the measurement
model.</li>
<li><code>rprior</code> and <code>dprior</code>: simulator and density
evaluation procedure, respectively, for the prior distribution.</li>
<li><code>skeleton</code>: evaluation of the deterministic
skeleton.</li>
<li><code>partrans</code>: parameter transformations.</li>
</ul></li>
</ul>
<p>The term <em>basic model component</em> is meant to refer to the
procedure itself, as distinct from the execution of the procedure. The
user specifies the procedure (in one of several forms); the package
decides when and where to execute the procedure.</p>
<ul>
<li><p><em>Workhorses</em>: <strong>R</strong> functions, built into the
package, that cause the basic model component procedures to be executed.
Each workhorse has a name that matches that of the corresponding basic
model component. In addition, there is the <code>trajectory</code>
workhorse, which iterates or integrates the deterministic skeleton
(according to whether it is a map or a vectorfield, respectively) to
obtain state trajectories.</p></li>
<li><p><em>Elementary POMP algorithms</em>: algorithms that interrogate
the model or the model/data confrontation without attempting to estimate
parameters. There are currently four of these:</p>
<ul>
<li><code>simulate</code> performs simulations of the POMP model, i.e.,
it samples from the joint distribution of latent states and
observables.</li>
<li><code>pfilter</code> runs a sequential Monte Carlo (particle filter)
algorithm to compute the likelihood and (optionally) estimate the
prediction and filtering distributions of the latent state process.</li>
<li><code>probe</code> computes one or more uni- or multi-variate
summary statistics on both actual and simulated data.</li>
<li><code>spect</code> estimates the power spectral density functions
for the actual and simulated data.</li>
</ul></li>
<li><p><em>POMP estimation algorithms</em>: procedures that build on the
elementary algorithms and are used for estimation of parameters and
other inferential tasks. There are currently ten of these:</p>
<ul>
<li><code>abc</code>: approximate Bayesian computation</li>
<li><code>bsmc2</code>: Liu-West algorithm for Bayesian SMC</li>
<li><code>pmcmc</code>: a particle MCMC algorithm</li>
<li><code>mif2</code>: iterated filtering (IF2)</li>
<li><code>enkf</code>: ensemble Kalman filter</li>
<li><code>eakf</code>: ensemble adjusted Kalman filter</li>
<li><code>traj_objfun</code>: trajectory matching</li>
<li><code>spect_objfun</code>: power spectrum matching</li>
<li><code>probe_objfun</code>: probe matching</li>
<li><code>nlf_objfun</code>: nonlinear forecasting</li>
</ul></li>
<li><p><em>Objective function methods</em>: among the estimation
algorithms just listed, four are methods that construct stateful
objective functions that can be optimized using general-purpose
numerical optimization algorithms such as <code>optim</code>,
<code>subplex</code>, or the optimizers in the <strong>nloptr</strong>
package. These have certain new features that will be described
below.</p></li>
</ul>
</div>
<div id="changes-in-the-way-models-are-specified" class="section level2">
<h2>Changes in the way models are specified</h2>
<div id="basic-component-specification" class="section level3">
<h3>Basic component specification</h3>
<p>The manner in which one writes <strong>R</strong> functions to
specify basic model components has been totally changed. Before, one
wrote functions that took specific arguments such as <code>x</code>,
<code>params</code>, and <code>covars</code>. Now, one writes such
functions with any or all state variables, observables, covariates,
and/or time as arguments. Thus for example, in versions &lt;2, one might
have specified a measurement model density evaluator (‘dmeasure’)
so:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>...,</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>dmeasure <span class="ot">=</span> <span class="cf">function</span> (y, x, t, params, covars, ..., log) {</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="fu">dnbinom</span>(<span class="at">x=</span>y[<span class="st">&quot;count&quot;</span>],<span class="at">mu=</span>x[<span class="st">&quot;s&quot;</span>],<span class="at">size=</span>params[<span class="st">&quot;theta&quot;</span>],<span class="at">log=</span>log)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>},</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>...</span></code></pre></div>
<p>Here, the state variable “s”, passed via the argument <code>x</code>
is the expected value of the observable “count”, which is assumed to be
negative-binomially distributed with size parameter “theta”. The
observables are passed via the vector <code>y</code> and the parameters
via the vector <code>params</code> and so the variables of interest must
be extracted by name from these vectors. Note that the time variable
<code>t</code> is not used but must nevertheless be named as a formal
argument.</p>
<p>In <strong>pomp</strong> version 2, the corresponding ‘dmeasure’
specification would be</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>...,</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>dmeasure <span class="ot">=</span> <span class="cf">function</span> (count, s, theta, ..., log) {</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  <span class="fu">dnbinom</span>(<span class="at">x=</span>count,<span class="at">mu=</span>s,<span class="at">size=</span>theta,<span class="at">log=</span>log)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>},</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>...</span></code></pre></div>
<p>Note that there is no longer a need to extract the relevant variables
from vectors. Moreover, the only required argument is <code>...</code>.
The available arguments are taken from the set of observables, state
variables, parameters, covariates, and time, as before.</p>
<p>These remarks apply whenever one specifies a basic model component
using an <strong>R</strong> function. For the most part, C snippets that
worked with <strong>pomp</strong> version &lt;2 will continue to work.
The exception is that parameter transformation C snippets may need to be
rewritten (see below).</p>
</div>
<div id="process-model-specification" class="section level3">
<h3>Process model specification</h3>
<p>Prior to version 2, one specified the <code>rprocess</code> component
using one of the plugins <code>onestep.sim</code>,
<code>discrete.time.sim</code>, <code>euler.sim</code>,
<code>gillespie.sim</code>, or <code>gillespie.hl.sim</code>. These have
been renamed <code>onestep</code>, <code>discrete_time</code>,
<code>euler</code>, <code>gillespie</code>, and
<code>gillespie_hl</code>, respectively, but are otherwise
unchanged.</p>
<p>Note that, if one uses an <strong>R</strong> function to specify the
process model simulator, the remarks above under “Basic component
specification” apply.</p>
</div>
<div id="initialization-of-the-latent-state-process" class="section level3">
<h3>Initialization of the latent state process</h3>
<p>In <strong>pomp</strong> versions &lt;2, one simulated from the
distribution of the latent state process via the “initializer”
component. As of version 2, this has been renamed “rinit”. The “rinit”
component is supplied to <strong>pomp</strong> functions using the
argument of the same name.</p>
<p>If <code>rinit</code> is not explicitly specified, the default
behavior is to treat any parameters ending with suffices <code>_0</code>
or <code>.0</code> as the values of correspondingly named latent state
variables at time <code>t0</code>.</p>
</div>
</div>
<div id="covariates" class="section level2">
<h2>Covariates</h2>
<p>Prior to version 2, time-varying covariates upon which basic model
components depended were supplied via the two arguments
<code>covar</code> and <code>tcovar</code> to <code>pomp</code>. For
example, in one of the examples, we see</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">cbind</span>(</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="at">time=</span><span class="fu">seq</span>(<span class="at">from=</span><span class="dv">1928</span>,<span class="at">to=</span><span class="dv">1934</span>,<span class="at">by=</span><span class="fl">0.01</span>),</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="fu">as.data.frame</span>(</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>    <span class="fu">periodic_bspline_basis</span>(</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>      <span class="at">x=</span><span class="fu">seq</span>(<span class="at">from=</span><span class="dv">1928</span>,<span class="at">to=</span><span class="dv">1934</span>,<span class="at">by=</span><span class="fl">0.01</span>),</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>      <span class="at">nbasis=</span><span class="dv">3</span>,</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>      <span class="at">degree=</span><span class="dv">3</span>,</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>      <span class="at">period=</span><span class="dv">1</span>,</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>      <span class="at">names=</span><span class="st">&quot;seas%d&quot;</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>    )</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>  ),</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>  <span class="at">pop=</span>dat<span class="sc">$</span>population</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>) <span class="ot">-&gt;</span> covar</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a><span class="fu">pomp</span>(</span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>  ...,</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>  <span class="at">covar=</span>covar,</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>  <span class="at">tcovar=</span><span class="st">&quot;time&quot;</span>,</span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a>  ...</span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a>)</span></code></pre></div>
<p>Note that, as this example illustrates, it was often necessary to
first construct the covariate table as a data frame before passing it as
argument to <code>pomp</code>.</p>
<p>As of version 2, one includes such time-varying covariates as
specially constructed table via the single argument <code>covar</code>,
which can be furnished to any POMP elementary or estimation algorithm.
One constructs a covariate table using the <code>covariate_table</code>
command. The syntax for specifying a covariate table is quite flexible.
In particular, the arguments to <code>covariate_table</code> are
evaluated sequentially, so that later ones can depend on earlier ones.
Once evaluated, the covariates are bound column-wise into a single data
frame. One can also provide a data frame to
<code>covariate_table</code>, along with the name of the time variable,
which matches the old usage very closely. Thus, one might use the
following in place of the above:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">pomp</span>(</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  ...,</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  <span class="at">covar=</span><span class="fu">covariate_table</span>(</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>    <span class="at">t=</span><span class="fu">seq</span>(<span class="at">from=</span><span class="dv">1928</span>,<span class="at">to=</span><span class="dv">1934</span>,<span class="at">by=</span><span class="fl">0.01</span>),</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    <span class="at">seas=</span><span class="fu">periodic_bspline_basis</span>(t,<span class="at">nbasis=</span><span class="dv">3</span>,<span class="at">degree=</span><span class="dv">3</span>,<span class="at">period=</span><span class="dv">1</span>),</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>    <span class="at">pop=</span>dat<span class="sc">$</span>population,</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>    <span class="at">times=</span><span class="st">&quot;t&quot;</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>  ),</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>  ...</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>)</span></code></pre></div>
<p>Prior to version 2, covariates were always linearly interpolated when
furnished to any of the basic model components. As of version 2,
although linear interpolation remains the default, one can also use the
<code>order</code> argument to direct that the covariates be treated as
piecewise-constant, right-continuous functions.</p>
</div>
<div id="parameter-transformations" class="section level2">
<h2>Parameter transformations</h2>
<p>In <strong>pomp</strong> version &lt;2, one specified parameter
transformations by means to two arguments to <code>pomp</code>:
<code>fromEstimationScale</code> and <code>toEstimationScale</code>. As
of version 2, both forward and inverse transformations are encapsulated
in a single object passed via the <code>partrans</code> argument to any
of the <strong>pomp</strong> elementary or inference algorithms. The
parameter transformation object is constructed by means of a call to
<code>parameter_trans</code>. One can specify general forward and
inverse transformations via the <code>fromEst</code> and
<code>toEst</code> arguments to this function. If these are specified
using <strong>R</strong> functions, the remarks above (“Basic component
specification”) apply. If one specifies these using C snippets, the
syntax has changed from that of versions &lt;2. In particular, when
writing C snippets for parameter transformations, for a parameter “p”,
the notation <code>p</code> always refers to <code>p</code> on the
natural scale and <code>T_p</code> refers to its value of <code>p</code>
on the estimation scale. Thus, if parameter “alpha” is to be
log-transformed for estimation, the <code>toEst</code> snippet would
contain the line</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>T_alpha <span class="op">=</span> log<span class="op">(</span>alpha<span class="op">);</span></span></code></pre></div>
<p>and the <code>fromEst</code> snippet would include</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>alpha <span class="op">=</span> exp<span class="op">(</span>T_alpha<span class="op">);</span></span></code></pre></div>
<p>Because many use cases involve simply log, logit, or log-barycentric
transformations, one can handle these cases without needing to write
<code>toEst</code> and <code>fromEst</code> C snippets, by naming the
parameters to be so transformed in the <code>log</code>,
<code>logit</code>, and <code>barycentric</code> arguments of
<code>parameter_trans</code>. When these arguments are supplied,
<code>parameter_trans</code> internally writes a pair of C snippets to
implement the transformations. As with other cases when one refers to
parameters in C snippets, one must include all parameters named in the
<code>paramnames</code> argument.</p>
<p>At any point, if one sets <code>partrans = NULL</code> in an
elementary or inference algorithm, the parameter transformations are
reset to the identity transformation.</p>
</div>
<div id="accumulator-variables" class="section level2">
<h2>Accumulator variables</h2>
<p>In <strong>pomp</strong> versions &lt;2, one named accumulator
variables in the <code>zeronames</code> argument of <code>pomp</code>.
This argument has been renamed <code>accumvars</code>: it can be
supplied to any <strong>pomp</strong> elementary or estimation
algorithm.</p>
</div>
<div id="changes-in-elementary-pomp-algorithms" class="section level2">
<h2>Changes in elementary POMP algorithms</h2>
<div id="simulate" class="section level3">
<h3><code>simulate</code></h3>
<p>In <strong>pomp</strong> versions &lt;2, if one wanted to simulate a
POMP model, one had to construct a ‘pomp’ first, via a call to
<code>pomp</code>. The package structure necessitated that one provide a
dummy data frame to <code>pomp</code>, a fairly artificial proceeding.
As of version 2, one can simulate a POMP model without reference to any
data at all. One simply calls <code>simulate</code> with the necessary
arguments supplied. The needed arguments include <code>times</code>,
<code>t0</code>, and <code>rprocess</code>. One can optionally provide
<code>rinit</code> and <code>rmeasure</code>.</p>
<p>The format of the expressions returned by <code>simulate</code> is
determined by the new <code>format</code> argument. The old
<code>obs</code>, <code>states</code>, and <code>as.data.frame</code>
arguments have been eliminated. See <code>?simulate</code> for more
information.</p>
<p><code>simulate</code> now returns more informative results when
simulations from multiple parameter sets are simultaneously computed.
Specifically, if on the call to <code>simulate</code>,
<code>params</code> has column names, these are used to identify the
resulting simulations. Thus when <code>format = &quot;pomps&quot;</code> (the
default), the names of the resulting list of pomps will be constructed
from the column names of <code>params</code>. Likewise, when
<code>format = &quot;arrays&quot;</code>, the resulting arrays will have
informative column names and when <code>format = &quot;data.frame&quot;</code>,
the identifier variable will make use of the column names.</p>
</div>
<div id="pfilter-and-bsmc2" class="section level3">
<h3><code>pfilter</code> and <code>bsmc2</code></h3>
<p>The basic particle filter, <code>pfilter</code>, has a simpler mode
of operation. In calls to <code>pfilter</code>, <code>params</code>
should be a single parameter set only. That is, one can no longer
possible to pass a matrix of parameters to <code>pfilter</code>.</p>
<p>Similarly, the Liu-West algorithm, <code>bsmc2</code>, has a simpler
mode of operation. In calls to <code>bsmc2</code>, <code>params</code>
should be a single parameter set only. The requisite <code>Np</code>
particles are drawn from the distribution specified by the “rprior”
basic model component.</p>
</div>
</div>
<div id="change-in-pomp-estimation-algorithms" class="section level2">
<h2>Change in <strong>pomp</strong> estimation algorithms</h2>
<div id="parameter-transformations-in-estimation" class="section level3">
<h3>Parameter transformations in estimation</h3>
<p>In <strong>pomp</strong> versions &lt;2, several of the estimation
algorithms had a logical <code>transform</code> option. Setting
<code>transform = TRUE</code> caused estimation to be performed on the
transformed scale, if parameter transformations had been supplied. As of
version 2, transformations are automatically applied when it is
appropriate to do so and when they exist. One can remove transformations
by simply setting <code>partrans = NULL</code> in the call to any
<strong>pomp</strong> estimation algorithm.</p>
</div>
<div id="mif2-defaults" class="section level3">
<h3><code>mif2</code> defaults</h3>
<p>The default cooling schedule (<code>cooling.type</code>) in
<code>mif2</code> is now “geometric”, in contrast to “hyperbolic”, as
before.</p>
</div>
<div id="params-not-start" class="section level3">
<h3><code>params</code> not <code>start</code></h3>
<p>To specify the parameters used to start an iterative estimation
algorithm, such as <code>mif2</code>, <code>pmcmc</code>, or
<code>abc</code>, use the <code>params</code> argument. In
<strong>pomp</strong> versions &lt; 2, these functions had an argument
named <code>start</code> for this purpose.</p>
</div>
<div id="changes-in-optimization-based-methods-probe-matching-spectrum-matching-trajectory-matching-nonlinear-forecasting" class="section level3">
<h3>Changes in optimization-based methods: probe matching, spectrum
matching, trajectory matching, nonlinear forecasting</h3>
<p>In <strong>pomp</strong> versions &lt;2, the functions
<code>probe.match</code>, <code>spect.match</code>,
<code>traj.match</code>, and <code>nlf</code> called numerical
optimizers (e.g., <code>optim</code> or optimizers from the
<strong>subplex</strong> or <strong>nloptr</strong> packages) to
estimate model parameters by minimizing their respective objective
functions. As of version 2, these functions are no longer part of the
package. Their functionality has been replaced by a new set of
<em>objective function</em> methods.</p>
<p>The functions <code>probe_objfun</code>, <code>spect_objfun</code>,
<code>traj_objfun</code>, and <code>nlf_objfun</code> construct
<em>stateful objective functions</em>. These functions can be passed to
any <code>optim</code>-like numerical minimization routine. This is a
large increase in the flexibility of the package, since one is free to
choose essentially any minimization routine.</p>
<p>The fact that the objective functions are stateful means that each
such function stores in memory the results of the last time it was
called. This makes it very easy to extract information about the fitted
model regardless of the optimization routine. See the help documentation
for examples.</p>
</div>
</div>
<div id="changes-in-pomp-workhorses" class="section level2">
<h2>Changes in <strong>pomp</strong> workhorses</h2>
<div id="default-model-components" class="section level3">
<h3>Default model components</h3>
<p>In <strong>pomp</strong> version &lt;2, attempts to use a basic model
component that had not been defined by the user resulted in an error
message. The exception to this was the initial latent state sampler
<code>initializer</code> which had a default setting. As of version 2,
all the basic model components now have defaults.</p>
<ul>
<li>The default <code>rinit</code> behavior remains as it was: it
assumes the initial state distribution is concentrated at a point mass
determined by parameters with <code>.0</code> or <code>_0</code>
suffices.</li>
<li>The default process model is “missing”: calls to
<code>dprocess</code> and <code>rprocess</code> will result in missing
values (<code>NA</code>).</li>
<li>The default measurement model is “missing” as well.</li>
<li>The default prior is flat and improper: all calls to the default
<code>dprior</code> result in 1 (0 if <code>log = TRUE</code>), and all
calls to <code>rprior</code> result in <code>NA</code>.</li>
<li>The default skeleton is missing.</li>
<li>The default parameter transformations remain the identity.</li>
</ul>
<p>From the user’s point of view, this means, for example, that a call
to <code>simulate</code> when <code>rmeasure</code> has not been
specified will result in either empty or missing observables. If
<code>rprocess</code> has not been specified, then a call to
<code>simulate</code> will likewise return either zero latent state
variables, or latent state variables with <code>NA</code> values.</p>
</div>
<div id="skeleton" class="section level3">
<h3><code>skeleton</code></h3>
<p>In <code>skeleton</code>, the <code>t</code> argument has been
replaced by <code>times</code>, to make this uniform with the other
workhorse functions.</p>
</div>
<div id="trajectory" class="section level3">
<h3><code>trajectory</code></h3>
<p>The <code>as.data.frame</code> argument to <code>trajectory</code>
has been removed in favor of a new <code>format</code> argument that
allows one to choose between receiving the results in the form of an
array or a data frame.</p>
<p>When <code>trajectory</code> calls on <code>deSolve</code> routines
to numerically integrate a model vectorfield, more informative error
messages are generated, and diagnostics are printed when
<code>verbose = TRUE</code>.</p>
</div>
<div id="flow" class="section level3">
<h3><code>flow</code></h3>
<p>A new workhorse has been introduced, similar to
<code>trajectory</code> but at a lower level. The <code>flow</code>
function iterates or integrates the deterministic skeleton to return
trajectories. See <code>?flow</code> for details.</p>
</div>
<div id="rprocess" class="section level3">
<h3><code>rprocess</code></h3>
<p>The call to <code>rprocess</code> has changed. One now retrieves
simulations of the latent state process by doing</p>
<pre><code>rprocess(object, x0, t0, times, params)</code></pre>
<p>where <code>object</code>, as usual, is the pomp, <code>x0</code> is
the named vector or matrix with rownames giving the state of the process
at time <code>t0</code>, <code>times</code> are the times at which one
desires simulated states, and <code>params</code> are the
parameters.</p>
</div>
</div>
<div id="included-pomp-examples" class="section level2">
<h2>Included <strong>pomp</strong> examples</h2>
<p>The <code>pompExample</code> function has been eliminated. The suite
of toy examples has been enlarged, but these are accessed via calls to
ordinary package functions. Thus, for example, one creates the Ricker
toy model via a call to <code>ricker()</code> and the SIR model
simulated via Euler’s method via a call to <code>sir()</code>. See the
documentation for a full list of toy examples</p>
</div>
<div id="included-datasets" class="section level2">
<h2>Included datasets</h2>
<p>A number of new datasets are provided with the package. See
<code>data(package=&quot;pomp&quot;)</code> for a full list.</p>
</div>
<div id="facilities-removed-in-version-2" class="section level2">
<h2>Facilities removed in version 2</h2>
<ul>
<li>The <code>probe.match</code>, <code>spect.match</code>,
<code>traj.match</code>, and <code>nlf</code> functions have been
removed entirely. The new approach to parameter estimation based on
numerical optimization involves constructing stateful objective
functions. See above.</li>
<li>The old and deprecated <code>mif</code> and <code>bsmc</code>
methods have been removed.</li>
<li>The <code>measurement.model</code> argument to <code>pomp</code> has
been removed. It is now necessary to specify the measurement model
directly using <code>rmeasure</code> and/or <code>dmeasure</code>.</li>
<li>The <code>conv.rec</code> method has been deprecated, replaced by
the new <code>traces</code> method.</li>
<li>The use of <code>$</code> methods to access the slots of
<code>pomp</code> S4 objects has now been removed.</li>
</ul>
</div>
<div id="recoding-your-models-for-pomp-version-2-examples" class="section level2">
<h2>Recoding your models for <strong>pomp</strong> version 2:
examples</h2>
<p>The following two examples are taken from the <a href="https://doi.org/10.18637/jss.v069.i12"><strong>pomp</strong>
<em>Journal of Statistical Software</em> paper</a>. In each case, we
first look at the <strong>pomp</strong> version &lt;2 implementation,
then at the version 2 implementation.</p>
<div id="gompertz-model" class="section level3">
<h3>Gompertz model</h3>
<p>First, the Gompertz model, which has a single latent state variable,
<span class="math inline">\(X\)</span>, and a single observable, <span class="math inline">\(Y\)</span>. The model is defined by the relations
<span class="math display">\[\begin{gathered}
S = e^{r \delta}\\
X(t+\delta)\;\sim\;\mathrm{Lognormal}\left(\log(K^{1-S}\,X^S),\sigma\right)\\
Y(t)\;\sim\;\mathrm{Lognormal}\left(\log{X(t)},\tau\right)
\end{gathered}\]</span> where <span class="math inline">\(r\)</span>,
<span class="math inline">\(K\)</span>, <span class="math inline">\(\sigma\)</span>, and <span class="math inline">\(\tau\)</span> are parameters and <span class="math inline">\(\delta\)</span> is the discrete time-step.</p>
<p>Here is how the model was implemented in <strong>pomp</strong>
version &lt;2. We write all the basic model components using
<strong>R</strong> functions assuming <span class="math inline">\(\delta=1\)</span>. We also do one simulation.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="do">## rprocess</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>gompertz.proc.sim <span class="ot">&lt;-</span> <span class="cf">function</span> (x, t, params, delta.t, ...) {</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  eps <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="fu">rnorm</span>(<span class="at">n=</span><span class="dv">1</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span>params[<span class="st">&quot;sigma&quot;</span>]))</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>  S <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="sc">-</span>params[<span class="st">&quot;r&quot;</span>]<span class="sc">*</span>delta.t)</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>  <span class="fu">setNames</span>(params[<span class="st">&quot;K&quot;</span>]<span class="sc">^</span>(<span class="dv">1</span><span class="sc">-</span>S)<span class="sc">*</span>x[<span class="st">&quot;X&quot;</span>]<span class="sc">^</span>S<span class="sc">*</span>eps,<span class="st">&quot;X&quot;</span>)</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>}</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="do">## rmeasure</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>gompertz.meas.sim <span class="ot">&lt;-</span> <span class="cf">function</span> (x, t, params, ...) {</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>  <span class="fu">setNames</span>(<span class="fu">rlnorm</span>(<span class="at">n=</span><span class="dv">1</span>,<span class="at">meanlog=</span><span class="fu">log</span>(x[<span class="st">&quot;X&quot;</span>]),<span class="at">sd=</span>params[<span class="st">&quot;tau&quot;</span>]),<span class="st">&quot;Y&quot;</span>)</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>}</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="do">## dmeasure</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>gompertz.meas.dens <span class="ot">&lt;-</span> <span class="cf">function</span> (y, x, t, params, log, ...) {</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>  <span class="fu">dlnorm</span>(<span class="at">x=</span>y[<span class="st">&quot;Y&quot;</span>],<span class="at">meanlog=</span><span class="fu">log</span>(x[<span class="st">&quot;X&quot;</span>]),<span class="at">sdlog=</span>params[<span class="st">&quot;tau&quot;</span>],<span class="at">log=</span>log)</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>}</span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a><span class="do">## initializer</span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>gompertz.init <span class="ot">&lt;-</span> <span class="cf">function</span> (t0, params, ...) {</span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>  <span class="fu">setNames</span>(params[<span class="st">&quot;X_0&quot;</span>],<span class="st">&quot;X&quot;</span>)</span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>}</span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a><span class="do">## Parameter transformations</span></span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>gompertz.log.tf <span class="ot">&lt;-</span> <span class="cf">function</span> (params, ...) <span class="fu">log</span>(params)</span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a>gompertz.exp.tf <span class="ot">&lt;-</span> <span class="cf">function</span> (params, ...) <span class="fu">exp</span>(params)</span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a><span class="do">## pomp construction</span></span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a><span class="fu">pomp</span>(</span>
<span id="cb8-29"><a href="#cb8-29" tabindex="-1"></a>  <span class="at">data=</span><span class="fu">data.frame</span>(<span class="at">time=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, <span class="at">Y=</span><span class="cn">NA</span>), </span>
<span id="cb8-30"><a href="#cb8-30" tabindex="-1"></a>  <span class="at">times=</span><span class="st">&quot;time&quot;</span>, <span class="at">t0=</span><span class="dv">0</span>,</span>
<span id="cb8-31"><a href="#cb8-31" tabindex="-1"></a>  <span class="at">rprocess=</span><span class="fu">discrete.time.sim</span>(<span class="at">step.fun=</span>gompertz.proc.sim,<span class="at">delta.t=</span><span class="dv">1</span>), </span>
<span id="cb8-32"><a href="#cb8-32" tabindex="-1"></a>  <span class="at">rmeasure=</span>gompertz.meas.sim,</span>
<span id="cb8-33"><a href="#cb8-33" tabindex="-1"></a>  <span class="at">dmeasure=</span>gompertz.meas.dens,</span>
<span id="cb8-34"><a href="#cb8-34" tabindex="-1"></a>  <span class="at">initializer=</span>gompertz.init,</span>
<span id="cb8-35"><a href="#cb8-35" tabindex="-1"></a>  <span class="at">toEstimationScale=</span>gompertz.log.tf,</span>
<span id="cb8-36"><a href="#cb8-36" tabindex="-1"></a>  <span class="at">fromEstimationScale=</span>gompertz.exp.tf,</span>
<span id="cb8-37"><a href="#cb8-37" tabindex="-1"></a>  <span class="at">params=</span><span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.1</span>,<span class="at">K=</span><span class="dv">1</span>,<span class="at">sigma=</span><span class="fl">0.1</span>,<span class="at">tau=</span><span class="fl">0.1</span>,<span class="at">X_0=</span><span class="dv">1</span>)</span>
<span id="cb8-38"><a href="#cb8-38" tabindex="-1"></a>) <span class="ot">-&gt;</span> gomp1R</span>
<span id="cb8-39"><a href="#cb8-39" tabindex="-1"></a></span>
<span id="cb8-40"><a href="#cb8-40" tabindex="-1"></a><span class="fu">simulate</span>(gomp1R) <span class="ot">-&gt;</span> gomp1R</span></code></pre></div>
<p>Now, we implement the same model using <strong>pomp</strong> version
2. Note that <code>initializer</code> becomes <code>rinit</code> and
that <code>discrete.time.sim</code> becomes <code>discrete_time</code>.
Also, the parameter transformation syntax is different.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">library</span>(pomp)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="do">## rprocess</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>gompertz.proc.sim <span class="ot">&lt;-</span> <span class="cf">function</span> (X, r, K, sigma, delta.t, ...) {</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  eps <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="fu">rnorm</span>(<span class="at">n=</span><span class="dv">1</span>,<span class="at">mean=</span><span class="dv">0</span>,<span class="at">sd=</span>sigma))</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  S <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="sc">-</span>r<span class="sc">*</span>delta.t)</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>  <span class="fu">c</span>(<span class="at">X=</span>K<span class="sc">^</span>(<span class="dv">1</span><span class="sc">-</span>S)<span class="sc">*</span>X<span class="sc">^</span>S<span class="sc">*</span>eps)</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>}</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="do">## rmeasure</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>gompertz.meas.sim <span class="ot">&lt;-</span> <span class="cf">function</span> (X, tau, ...) {</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>  <span class="fu">c</span>(<span class="at">Y=</span><span class="fu">rlnorm</span>(<span class="at">n=</span><span class="dv">1</span>,<span class="at">meanlog=</span><span class="fu">log</span>(X),<span class="at">sd=</span>tau))</span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a>}</span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="do">## dmeasure</span></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a>gompertz.meas.dens <span class="ot">&lt;-</span> <span class="cf">function</span> (X, tau, Y, log, ...) {</span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a>  <span class="fu">dlnorm</span>(<span class="at">x=</span>Y,<span class="at">meanlog=</span><span class="fu">log</span>(X),<span class="at">sdlog=</span>tau,<span class="at">log=</span>log)</span>
<span id="cb9-18"><a href="#cb9-18" tabindex="-1"></a>}</span>
<span id="cb9-19"><a href="#cb9-19" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" tabindex="-1"></a><span class="do">## rinit</span></span>
<span id="cb9-21"><a href="#cb9-21" tabindex="-1"></a>gompertz.init <span class="ot">&lt;-</span> <span class="cf">function</span> (X_0, ...) {</span>
<span id="cb9-22"><a href="#cb9-22" tabindex="-1"></a>  <span class="fu">c</span>(<span class="at">X=</span>X_0)</span>
<span id="cb9-23"><a href="#cb9-23" tabindex="-1"></a>}</span>
<span id="cb9-24"><a href="#cb9-24" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" tabindex="-1"></a><span class="do">## pomp construction via simulation</span></span>
<span id="cb9-26"><a href="#cb9-26" tabindex="-1"></a><span class="fu">simulate</span>(</span>
<span id="cb9-27"><a href="#cb9-27" tabindex="-1"></a>  <span class="at">times=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, <span class="at">t0=</span><span class="dv">0</span>,</span>
<span id="cb9-28"><a href="#cb9-28" tabindex="-1"></a>  <span class="at">rprocess=</span><span class="fu">discrete_time</span>(gompertz.proc.sim,<span class="at">delta.t=</span><span class="dv">1</span>), </span>
<span id="cb9-29"><a href="#cb9-29" tabindex="-1"></a>  <span class="at">rmeasure=</span>gompertz.meas.sim,</span>
<span id="cb9-30"><a href="#cb9-30" tabindex="-1"></a>  <span class="at">dmeasure=</span>gompertz.meas.dens,</span>
<span id="cb9-31"><a href="#cb9-31" tabindex="-1"></a>  <span class="at">rinit=</span>gompertz.init,</span>
<span id="cb9-32"><a href="#cb9-32" tabindex="-1"></a>  <span class="at">partrans=</span><span class="fu">parameter_trans</span>(<span class="at">log=</span><span class="fu">c</span>(<span class="st">&quot;K&quot;</span>,<span class="st">&quot;r&quot;</span>,<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;tau&quot;</span>)),</span>
<span id="cb9-33"><a href="#cb9-33" tabindex="-1"></a>  <span class="at">paramnames=</span><span class="fu">c</span>(<span class="st">&quot;K&quot;</span>,<span class="st">&quot;r&quot;</span>,<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;tau&quot;</span>),</span>
<span id="cb9-34"><a href="#cb9-34" tabindex="-1"></a>  <span class="at">params=</span><span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.1</span>,<span class="at">K=</span><span class="dv">1</span>,<span class="at">sigma=</span><span class="fl">0.1</span>,<span class="at">tau=</span><span class="fl">0.1</span>,<span class="at">X_0=</span><span class="dv">1</span>)</span>
<span id="cb9-35"><a href="#cb9-35" tabindex="-1"></a>) <span class="ot">-&gt;</span> gomp2R</span></code></pre></div>
<p>To implement the model using C snippets, in <strong>pomp</strong>
versions &lt;2 we might do the following.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">pomp</span>(</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="at">data=</span><span class="fu">data.frame</span>(<span class="at">time=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, <span class="at">Y=</span><span class="cn">NA</span>), </span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="at">times=</span><span class="st">&quot;time&quot;</span>, <span class="at">t0=</span><span class="dv">0</span>,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="at">rprocess=</span><span class="fu">discrete.time.sim</span>(</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>    <span class="at">step.fun=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="st">      double e = rnorm(0,sigma);</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="st">      double S = exp(-r*dt);</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="st">      X = exp((1-S)*log(K)+S*log(X)+e);</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="st">  &quot;</span>),</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>    <span class="at">delta.t=</span><span class="dv">1</span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>  ), </span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>  <span class="at">rmeasure=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="st">      Y = exp(rnorm(log(X),tau));</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a>  <span class="at">dmeasure=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a><span class="st">      lik = dlnorm(Y,log(X),tau,give_log);</span></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a>  <span class="at">initializer=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a><span class="st">      X = X_0;</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a>  <span class="at">toEstimationScale=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a><span class="st">      TK = log(K);</span></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="st">      Tr = log(r);</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a><span class="st">      Tsigma = log(sigma);</span></span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a><span class="st">      Ttau = log(tau);</span></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a><span class="st">      TX_0 = log(X_0);</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a>  <span class="at">fromEstimationScale=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a><span class="st">      TK = exp(K);</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a><span class="st">      Tr = exp(r);</span></span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a><span class="st">      Tsigma = exp(sigma);</span></span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a><span class="st">      Ttau = exp(tau);</span></span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a><span class="st">      TX_0 = exp(X_0);</span></span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>  <span class="at">paramnames=</span><span class="fu">c</span>(<span class="st">&quot;r&quot;</span>,<span class="st">&quot;K&quot;</span>,<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;tau&quot;</span>,<span class="st">&quot;X_0&quot;</span>),</span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>  <span class="at">statenames=</span><span class="st">&quot;X&quot;</span>,</span>
<span id="cb10-37"><a href="#cb10-37" tabindex="-1"></a>  <span class="at">params=</span><span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.1</span>,<span class="at">K=</span><span class="dv">1</span>,<span class="at">sigma=</span><span class="fl">0.1</span>,<span class="at">tau=</span><span class="fl">0.1</span>,<span class="at">X_0=</span><span class="dv">1</span>)</span>
<span id="cb10-38"><a href="#cb10-38" tabindex="-1"></a>) <span class="ot">-&gt;</span> gomp1C</span>
<span id="cb10-39"><a href="#cb10-39" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" tabindex="-1"></a><span class="fu">simulate</span>(gomp1C) <span class="ot">-&gt;</span> gomp1C</span></code></pre></div>
<p>In version 2, we would do something like the following. In addition
to the differences noted above, notice that we must specify
<code>obsnames</code> here, since the name of the observed variable is
not provided in a dummy data frame as in versions &lt;2. Note also that
no changes to the C snippets themselves are needed.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">simulate</span>(</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="at">times=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, <span class="at">t0=</span><span class="dv">0</span>,</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="at">rprocess=</span><span class="fu">discrete_time</span>(</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>    <span class="at">step.fun=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="st">      double e = rnorm(0,sigma);</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="st">      double S = exp(-r*dt);</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a><span class="st">      X = exp((1-S)*log(K)+S*log(X)+e);</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="st">  &quot;</span>),</span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    <span class="at">delta.t=</span><span class="dv">1</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>  ), </span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>  <span class="at">rmeasure=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="st">      Y = exp(rnorm(log(X),tau));</span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>  <span class="at">dmeasure=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a><span class="st">      lik = dlnorm(Y,log(X),tau,give_log);</span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>  <span class="at">rinit=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a><span class="st">      X = X_0;</span></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a><span class="st">    &quot;</span>),</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>  <span class="at">partrans=</span><span class="fu">parameter_trans</span>(<span class="at">log=</span><span class="fu">c</span>(<span class="st">&quot;K&quot;</span>,<span class="st">&quot;r&quot;</span>,<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;tau&quot;</span>)),</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>  <span class="at">paramnames=</span><span class="fu">c</span>(<span class="st">&quot;r&quot;</span>,<span class="st">&quot;K&quot;</span>,<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;tau&quot;</span>,<span class="st">&quot;X_0&quot;</span>),</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>  <span class="at">statenames=</span><span class="st">&quot;X&quot;</span>,</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a>  <span class="at">obsnames=</span><span class="st">&quot;Y&quot;</span>,</span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>  <span class="at">params=</span><span class="fu">c</span>(<span class="at">r=</span><span class="fl">0.1</span>,<span class="at">K=</span><span class="dv">1</span>,<span class="at">sigma=</span><span class="fl">0.1</span>,<span class="at">tau=</span><span class="fl">0.1</span>,<span class="at">X_0=</span><span class="dv">1</span>)</span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>) <span class="ot">-&gt;</span> gomp2C</span></code></pre></div>
</div>
<div id="sir-model" class="section level3">
<h3>SIR model</h3>
<p>This example, also drawn from the <a href="https://doi.org/10.18637/jss.v069.i12"><em>Journal of Statistical
Software</em> paper</a>, involves covariates and accumulator variables
as well as more complex parameter transformations.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="do">## Construct some fake birthrate data.</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="at">time=</span><span class="fu">seq</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="dv">11</span>,<span class="at">by=</span><span class="dv">1</span><span class="sc">/</span><span class="dv">12</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    <span class="at">birthrate=</span><span class="fl">5e5</span><span class="sc">*</span><span class="fu">bspline_basis</span>(time,<span class="at">nbasis=</span><span class="dv">5</span>)<span class="sc">%*%</span><span class="fu">c</span>(<span class="fl">0.018</span>,<span class="fl">0.019</span>,<span class="fl">0.021</span>,<span class="fl">0.019</span>,<span class="fl">0.015</span>)</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>  ) <span class="ot">-&gt;</span> birthdat</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="do">## measurement model C snippets</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>rmeas <span class="ot">&lt;-</span> <span class="st">&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="st">  cases = rnbinom_mu(theta, rho * H);</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="st">&quot;</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>dmeas <span class="ot">&lt;-</span> <span class="st">&quot;</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="st">  lik = dnbinom_mu(cases, theta, rho * H, give_log);</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a><span class="st">&quot;</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="do">## initializer</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>rinit <span class="ot">&lt;-</span> <span class="st">&quot;</span></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a><span class="st">  double m = popsize/(S_0 + I_0 + R_0);</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="st">  S = nearbyint(m*S_0);</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a><span class="st">  I = nearbyint(m*I_0);</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a><span class="st">  R = nearbyint(m*R_0);</span></span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a><span class="st">  H = 0;</span></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a><span class="st">  Phi = 0;</span></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a><span class="st">  noise = 0;</span></span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a><span class="st">&quot;</span></span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a><span class="do">## rprocess</span></span>
<span id="cb13-22"><a href="#cb13-22" tabindex="-1"></a>seas.sir.step <span class="ot">&lt;-</span> <span class="st">&quot;</span></span>
<span id="cb13-23"><a href="#cb13-23" tabindex="-1"></a><span class="st">  double rate[6];</span></span>
<span id="cb13-24"><a href="#cb13-24" tabindex="-1"></a><span class="st">  double dN[6];</span></span>
<span id="cb13-25"><a href="#cb13-25" tabindex="-1"></a><span class="st">  double Beta;</span></span>
<span id="cb13-26"><a href="#cb13-26" tabindex="-1"></a><span class="st">  double dW;</span></span>
<span id="cb13-27"><a href="#cb13-27" tabindex="-1"></a><span class="st">  Beta = exp(b1 + b2 * cos(M_2PI * Phi) + b3 * sin(M_2PI * Phi));</span></span>
<span id="cb13-28"><a href="#cb13-28" tabindex="-1"></a><span class="st">  rate[0] = birthrate;</span></span>
<span id="cb13-29"><a href="#cb13-29" tabindex="-1"></a><span class="st">  rate[1] = Beta * (I + iota) / popsize;</span></span>
<span id="cb13-30"><a href="#cb13-30" tabindex="-1"></a><span class="st">  rate[2] = mu;</span></span>
<span id="cb13-31"><a href="#cb13-31" tabindex="-1"></a><span class="st">  rate[3] = gamma;</span></span>
<span id="cb13-32"><a href="#cb13-32" tabindex="-1"></a><span class="st">  rate[4] = mu;</span></span>
<span id="cb13-33"><a href="#cb13-33" tabindex="-1"></a><span class="st">  rate[5] = mu;</span></span>
<span id="cb13-34"><a href="#cb13-34" tabindex="-1"></a><span class="st">  dN[0] = rpois(rate[0] * dt);</span></span>
<span id="cb13-35"><a href="#cb13-35" tabindex="-1"></a><span class="st">  reulermultinom(2, S, &amp;rate[1], dt, &amp;dN[1]);</span></span>
<span id="cb13-36"><a href="#cb13-36" tabindex="-1"></a><span class="st">  reulermultinom(2, I, &amp;rate[3], dt, &amp;dN[3]);</span></span>
<span id="cb13-37"><a href="#cb13-37" tabindex="-1"></a><span class="st">  reulermultinom(1, R, &amp;rate[5], dt, &amp;dN[5]);</span></span>
<span id="cb13-38"><a href="#cb13-38" tabindex="-1"></a><span class="st">  dW = rnorm(dt, sigma * sqrt(dt));</span></span>
<span id="cb13-39"><a href="#cb13-39" tabindex="-1"></a><span class="st">  S += dN[0] - dN[1] - dN[2];</span></span>
<span id="cb13-40"><a href="#cb13-40" tabindex="-1"></a><span class="st">  I += dN[1] - dN[3] - dN[4];</span></span>
<span id="cb13-41"><a href="#cb13-41" tabindex="-1"></a><span class="st">  R += dN[3] - dN[5];</span></span>
<span id="cb13-42"><a href="#cb13-42" tabindex="-1"></a><span class="st">  Phi += dW;</span></span>
<span id="cb13-43"><a href="#cb13-43" tabindex="-1"></a><span class="st">  H += dN[1];</span></span>
<span id="cb13-44"><a href="#cb13-44" tabindex="-1"></a><span class="st">  noise += (dW - dt) / sigma;</span></span>
<span id="cb13-45"><a href="#cb13-45" tabindex="-1"></a><span class="st">&quot;</span></span>
<span id="cb13-46"><a href="#cb13-46" tabindex="-1"></a></span>
<span id="cb13-47"><a href="#cb13-47" tabindex="-1"></a>toest <span class="ot">&lt;-</span> <span class="st">&quot;</span></span>
<span id="cb13-48"><a href="#cb13-48" tabindex="-1"></a><span class="st">  to_log_barycentric(&amp;TS_0,&amp;S_0,3);</span></span>
<span id="cb13-49"><a href="#cb13-49" tabindex="-1"></a><span class="st">  Tsigma = log(sigma);</span></span>
<span id="cb13-50"><a href="#cb13-50" tabindex="-1"></a><span class="st">  Tiota = log(iota);</span></span>
<span id="cb13-51"><a href="#cb13-51" tabindex="-1"></a><span class="st">&quot;</span></span>
<span id="cb13-52"><a href="#cb13-52" tabindex="-1"></a></span>
<span id="cb13-53"><a href="#cb13-53" tabindex="-1"></a>fromest <span class="ot">&lt;-</span> <span class="st">&quot;</span></span>
<span id="cb13-54"><a href="#cb13-54" tabindex="-1"></a><span class="st">  from_log_barycentric(&amp;TS_0,&amp;S_0,3);</span></span>
<span id="cb13-55"><a href="#cb13-55" tabindex="-1"></a><span class="st">  Tsigma = exp(sigma);</span></span>
<span id="cb13-56"><a href="#cb13-56" tabindex="-1"></a><span class="st">  Tiota = exp(iota);</span></span>
<span id="cb13-57"><a href="#cb13-57" tabindex="-1"></a><span class="st">&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="at">time=</span><span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">10</span>,<span class="at">by=</span><span class="dv">1</span><span class="sc">/</span><span class="dv">52</span>),<span class="at">cases=</span><span class="cn">NA</span>) <span class="sc">%&gt;%</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  <span class="fu">pomp</span>(</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>    <span class="at">times=</span><span class="st">&quot;time&quot;</span>, <span class="at">t0=</span><span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">52</span>, </span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>    <span class="at">covar =</span> birthdat, <span class="at">tcovar =</span> <span class="st">&quot;time&quot;</span>,</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    <span class="at">dmeasure =</span> <span class="fu">Csnippet</span>(dmeas),</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>    <span class="at">rmeasure =</span> <span class="fu">Csnippet</span>(rmeas),</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    <span class="at">initializer=</span><span class="fu">Csnippet</span>(rinit),</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    <span class="at">rprocess =</span> <span class="fu">euler.sim</span>(</span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>      <span class="at">step.fun =</span> <span class="fu">Csnippet</span>(seas.sir.step), </span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>      <span class="at">delta.t =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">52</span><span class="sc">/</span><span class="dv">20</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>    ),</span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>    <span class="at">toEstimationScale=</span><span class="fu">Csnippet</span>(toest),</span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>    <span class="at">fromEstimationScale=</span><span class="fu">Csnippet</span>(fromest),</span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    <span class="at">statenames =</span> <span class="fu">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>, <span class="st">&quot;H&quot;</span>, <span class="st">&quot;Phi&quot;</span>, <span class="st">&quot;noise&quot;</span>),</span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>    <span class="at">paramnames =</span> <span class="fu">c</span>(<span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>, <span class="st">&quot;theta&quot;</span>, <span class="st">&quot;b1&quot;</span>, <span class="st">&quot;b2&quot;</span>, <span class="st">&quot;b3&quot;</span>,</span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>      <span class="st">&quot;popsize&quot;</span>,<span class="st">&quot;rho&quot;</span>, <span class="st">&quot;iota&quot;</span>, <span class="st">&quot;sigma&quot;</span>, <span class="st">&quot;S_0&quot;</span>, <span class="st">&quot;I_0&quot;</span>, <span class="st">&quot;R_0&quot;</span>), </span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>    <span class="at">zeronames =</span> <span class="fu">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;noise&quot;</span>),</span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    <span class="at">params =</span> <span class="fu">c</span>(<span class="at">popsize =</span> <span class="dv">500000</span>, <span class="at">iota =</span> <span class="dv">5</span>, <span class="at">gamma =</span> <span class="dv">26</span>, <span class="at">mu =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">50</span>,</span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>      <span class="at">b1 =</span> <span class="dv">6</span>, <span class="at">b2 =</span> <span class="fl">0.2</span>, <span class="at">b3 =</span> <span class="sc">-</span><span class="fl">0.1</span>, <span class="at">rho =</span> <span class="fl">0.1</span>, <span class="at">theta =</span> <span class="dv">100</span>, </span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>      <span class="at">sigma =</span> <span class="fl">0.3</span>, <span class="at">S_0 =</span> <span class="fl">0.055</span>, <span class="at">I_0 =</span> <span class="fl">0.002</span>, <span class="at">R_0 =</span> <span class="fl">0.94</span>)</span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span> </span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>  <span class="fu">simulate</span>() <span class="ot">-&gt;</span> sir1C</span></code></pre></div>
<p>When implementing the same model in <strong>pomp</strong> version 2,
we can use almost all the same C snippets without modification. The
exception is the C snippets for the parameter transformations. The
syntax for the inclusion of the covariates is different as is that used
to specify the names of the accumulator variables. For example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">simulate</span>(</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  <span class="at">times=</span><span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">10</span>,<span class="at">by=</span><span class="dv">1</span><span class="sc">/</span><span class="dv">52</span>), <span class="at">t0=</span><span class="sc">-</span><span class="dv">1</span><span class="sc">/</span><span class="dv">52</span>,</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  <span class="at">covar=</span><span class="fu">covariate_table</span>(birthdat,<span class="at">times=</span><span class="st">&quot;time&quot;</span>),</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>  <span class="at">dmeasure =</span> <span class="fu">Csnippet</span>(dmeas),</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  <span class="at">rmeasure =</span> <span class="fu">Csnippet</span>(rmeas),</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>  <span class="at">rinit=</span><span class="fu">Csnippet</span>(rinit),</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  <span class="at">rprocess =</span> <span class="fu">euler</span>(</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>    <span class="at">step.fun =</span> <span class="fu">Csnippet</span>(seas.sir.step), </span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>    <span class="at">delta.t =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">52</span><span class="sc">/</span><span class="dv">20</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>  ),</span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>  <span class="at">partrans=</span><span class="fu">parameter_trans</span>(</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>    <span class="at">toEst=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a><span class="st">      to_log_barycentric(&amp;T_S_0,&amp;S_0,3);</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="st">      T_sigma = log(sigma);</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a><span class="st">      T_iota = log(iota);&quot;</span>),</span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>    <span class="at">fromEst=</span><span class="fu">Csnippet</span>(<span class="st">&quot;</span></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a><span class="st">      from_log_barycentric(&amp;S_0,&amp;T_S_0,3);</span></span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a><span class="st">      sigma = exp(T_sigma);</span></span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a><span class="st">      iota = exp(T_iota);&quot;</span>)</span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a>  ),</span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a>  <span class="at">statenames =</span> <span class="fu">c</span>(<span class="st">&quot;S&quot;</span>, <span class="st">&quot;I&quot;</span>, <span class="st">&quot;R&quot;</span>, <span class="st">&quot;H&quot;</span>, <span class="st">&quot;Phi&quot;</span>, <span class="st">&quot;noise&quot;</span>),</span>
<span id="cb15-22"><a href="#cb15-22" tabindex="-1"></a>  <span class="at">obsnames=</span><span class="fu">c</span>(<span class="st">&quot;cases&quot;</span>),</span>
<span id="cb15-23"><a href="#cb15-23" tabindex="-1"></a>  <span class="at">paramnames =</span> <span class="fu">c</span>(<span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;mu&quot;</span>, <span class="st">&quot;theta&quot;</span>, <span class="st">&quot;b1&quot;</span>, <span class="st">&quot;b2&quot;</span>, <span class="st">&quot;b3&quot;</span>,</span>
<span id="cb15-24"><a href="#cb15-24" tabindex="-1"></a>    <span class="st">&quot;popsize&quot;</span>,<span class="st">&quot;rho&quot;</span>, <span class="st">&quot;iota&quot;</span>, <span class="st">&quot;sigma&quot;</span>, <span class="st">&quot;S_0&quot;</span>, <span class="st">&quot;I_0&quot;</span>, <span class="st">&quot;R_0&quot;</span>), </span>
<span id="cb15-25"><a href="#cb15-25" tabindex="-1"></a>  <span class="at">accumvars =</span> <span class="fu">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;noise&quot;</span>),</span>
<span id="cb15-26"><a href="#cb15-26" tabindex="-1"></a>  <span class="at">params =</span> <span class="fu">c</span>(<span class="at">popsize =</span> <span class="dv">500000</span>, <span class="at">iota =</span> <span class="dv">5</span>, <span class="at">gamma =</span> <span class="dv">26</span>, <span class="at">mu =</span> <span class="dv">1</span><span class="sc">/</span><span class="dv">50</span>,</span>
<span id="cb15-27"><a href="#cb15-27" tabindex="-1"></a>    <span class="at">b1 =</span> <span class="dv">6</span>, <span class="at">b2 =</span> <span class="fl">0.2</span>, <span class="at">b3 =</span> <span class="sc">-</span><span class="fl">0.1</span>, <span class="at">rho =</span> <span class="fl">0.1</span>, <span class="at">theta =</span> <span class="dv">100</span>, </span>
<span id="cb15-28"><a href="#cb15-28" tabindex="-1"></a>    <span class="at">sigma =</span> <span class="fl">0.3</span>, <span class="at">S_0 =</span> <span class="fl">0.055</span>, <span class="at">I_0 =</span> <span class="fl">0.002</span>, <span class="at">R_0 =</span> <span class="fl">0.94</span>)</span>
<span id="cb15-29"><a href="#cb15-29" tabindex="-1"></a>) <span class="ot">-&gt;</span> sir2C</span></code></pre></div>
<p>Note also that, for specifying the above parameter transformations,
<strong>pomp</strong> version 2 provides the alternate form</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">simulate</span>(</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  ...,</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  <span class="at">partrans=</span><span class="fu">parameter_trans</span>(</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    <span class="at">log=</span><span class="fu">c</span>(<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;iota&quot;</span>),</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>    <span class="at">barycentric=</span><span class="fu">c</span>(<span class="st">&quot;S_0&quot;</span>,<span class="st">&quot;I_0&quot;</span>,<span class="st">&quot;R_0&quot;</span>)</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>  ),</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>  ...</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>) <span class="ot">-&gt;</span> sir2C</span></code></pre></div>
<hr />
<p>This document was produced using <strong>pomp</strong> version
6.3.0.0 and <strong>R</strong> version 4.5.0.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
