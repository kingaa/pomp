<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>pomp C API</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>








</head>

<body>




<h1 class="title toc-ignore">pomp C API</h1>


<div id="TOC">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#random-variables">Random variables</a><ul>
<li><a href="#beta-binomial-distribution">Beta-binomial distribution</a></li>
<li><a href="#multinomial-distribution">Multinomial distribution</a></li>
<li><a href="#euler-multinomial-distribution">Euler-multinomial distribution</a></li>
<li><a href="#gamma-white-noise">Gamma white noise</a></li>
</ul></li>
<li><a href="#splines">Splines</a></li>
<li><a href="#transformations">Transformations</a><ul>
<li><a href="#logit-transformation">Logit transformation</a></li>
<li><a href="#log-barycentric-transformation">Log-barycentric transformation</a></li>
</ul></li>
<li><a href="#convenience-functions">Convenience functions</a><ul>
<li><a href="#vector-dot-product">Vector dot product</a></li>
<li><a href="#exponentialgeometric-rate-conversion">Exponential/geometric rate conversion</a></li>
</ul></li>
<li><a href="#access-to-the-userdata">Access to the userdata</a></li>
<li><a href="#prototypes-for-basic-model-components">Prototypes for basic model components</a><ul>
<li><a href="#indices">Indices</a></li>
<li><a href="#rinit">rinit</a></li>
<li><a href="#rprocess">rprocess</a></li>
<li><a href="#dprocess">dprocess</a></li>
<li><a href="#skeleton">skeleton</a></li>
<li><a href="#rmeasure">rmeasure</a></li>
<li><a href="#dmeasure">dmeasure</a></li>
<li><a href="#emeasure">emeasure</a></li>
<li><a href="#vmeasure">vmeasure</a></li>
<li><a href="#rprior">rprior</a></li>
<li><a href="#dprior">dprior</a></li>
<li><a href="#partrans">partrans</a></li>
</ul></li>
</ul>
</div>

<style type="text/css">
a:link, a:visited {
  color: #0000ff;
  text-decoration: none;
}
a:hover, a:active {
  color: #cc3333;
  text-decoration: none;
}
code {
  font-size: 110%;
}
</style>
<hr />
<div id="overview" class="section level2">
<h2>Overview</h2>
<p><strong>pomp</strong> provides C entry points to a number of facilities for model specification. Below, we describe these, providing the prototypical function calls and descriptions of their arguments.</p>
<p>The <a href="#prototypes-for-basic-model-components">final section</a> describes the prototypes for the basic model components. Users wishing to write libraries to hold basic model components must furnish functions of these prototypes that perform the basic model component computations.</p>
</div>
<div id="random-variables" class="section level2">
<h2>Random variables</h2>
<div id="beta-binomial-distribution" class="section level3">
<h3>Beta-binomial distribution</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">double</span> rbetabinom(<span class="dt">double</span> size, <span class="dt">double</span> prob, <span class="dt">double</span> theta);</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="dt">double</span> dbetabinom(<span class="dt">double</span> x, <span class="dt">double</span> size, <span class="dt">double</span> prob, </a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">double</span> theta, <span class="dt">int</span> give_log);</a></code></pre></div>
<p><span class="math inline">\(X\)</span> is said to be Beta-binomially distributed with size <span class="math inline">\(n\)</span>, mean probability <span class="math inline">\(p\)</span>, and dispersion parameter <span class="math inline">\(\theta\)</span> if <span class="math display">\[P \sim \mathrm{Beta}\left(\theta\,p,\theta\,(1-p)\right)\]</span> and <span class="math display">\[X|P \sim \mathrm{Binomial}\left(n,P\right).\]</span> If <span class="math inline">\(X\sim\mathrm{BetaBinomial}\left(n,p,\theta\right)\)</span>, then <span class="math display">\[\mathbb{E}\left[X\right]=n\,p\qquad\text{and}\qquad\mathrm{Var}\left[X\right]=n\,p\,(1-p)\,\frac{\theta+n}{\theta+1}.\]</span></p>
</div>
<div id="multinomial-distribution" class="section level3">
<h3>Multinomial distribution</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">double</span> dmultinom(<span class="dt">int</span> m, <span class="dt">const</span> <span class="dt">double</span> *prob, <span class="dt">double</span> *x, <span class="dt">int</span> give_log);</a></code></pre></div>
<p>The <strong>R</strong> C API provides a simulator for the multinomial distribution, <code>rmultinom</code>. See the “Rmath.h” header file for information on this facility. <strong>pomp</strong> provides an evaluator for the probability mass function (<code>dmultinom</code>) for this distribution.</p>
<p>Input:</p>
<ul>
<li><code>m</code> is a positive integer, is the dimension of the random variable.</li>
<li><code>prob</code> is a pointer to an <code>m</code>-vector of probabilities.</li>
<li><code>x</code> is a pointer to an <code>m</code>-vector containing the data.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if the log probability is desired.</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
</ul>
<p>The return value is the probability or log probability (as requested).</p>
</div>
<div id="euler-multinomial-distribution" class="section level3">
<h3>Euler-multinomial distribution</h3>
<div id="simulate-euler-multinomial-transitions" class="section level4">
<h4>Simulate Euler-multinomial transitions</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> reulermultinom(<span class="dt">int</span> m, <span class="dt">double</span> size, <span class="dt">const</span> <span class="dt">double</span> *rate,</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">double</span> dt, <span class="dt">double</span> *trans);</a></code></pre></div>
<p>Input:</p>
<ul>
<li><code>m</code>, a positive integer, is number of potential transitions (“deaths”).</li>
<li><code>size</code>, a positive integer, is the number of individuals at risk.</li>
<li><code>rate</code> is a pointer to the vector of transition (“death”) rates.</li>
<li><code>dt</code>, a positive real number, is the duration of time interval.</li>
<li><code>trans</code> is a pointer to the vector that will hold the random deviate.</li>
</ul>
<p>On return, <code>trans[0]</code>, …, <code>trans[m-1]</code> will be the numbers of individuals making each of the respective transitions.</p>
<p>See <a href="https://kingaa.github.io/manuals/pomp/html/distributions.html"><code>?reulermultinom</code></a> and <a href="./FAQ.html#eulermultinomial-approximation">FAQ 3.6</a> for more on the Euler-multinomial distributions.</p>
<p><strong>NB:</strong> <code>reulermultinom</code> does not call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> internally. This must be done by the calling program. But note that when <code>reulermultinom</code> is called inside a <strong>pomp</strong> rprocess, there is no need to call either <code>GetRNGState()</code> or <code>PutRNGState()</code>; this is handled by <strong>pomp</strong>.</p>
</div>
<div id="compute-probabilities-of-euler-multinomial-transitions" class="section level4">
<h4>Compute probabilities of Euler-multinomial transitions</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">double</span> deulermultinom(<span class="dt">int</span> m, <span class="dt">double</span> size, <span class="dt">const</span> <span class="dt">double</span> *rate,</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="dt">double</span> dt, <span class="dt">double</span> *trans, <span class="dt">int</span> give_log);</a></code></pre></div>
<p>Input:</p>
<ul>
<li><code>m</code>, a positive integer, is the number of potential transitions (“deaths”).</li>
<li><code>size</code>, a positive integer, is the number of individuals at risk.</li>
<li><code>rate</code> is a pointer to vector of transition (“death”) rates.</li>
<li><code>dt</code>, a positive real number, is the duration of time interval.</li>
<li><code>trans</code> is pointer to vector containing the data, which are numbers of individuals making the respective transitions.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if log probability is desired;</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
</ul>
<p>The value returned is the probability or log probability (as requested).</p>
<p>See <a href="https://kingaa.github.io/manuals/pomp/html/distributions.html"><code>?deulermultinom</code></a> and <a href="./FAQ.html#eulermultinomial-approximation">FAQ 3.6</a> for more on the Euler-multinomial distributions.</p>
</div>
</div>
<div id="gamma-white-noise" class="section level3">
<h3>Gamma white noise</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">double</span> rgammawn(<span class="dt">double</span> sigma, <span class="dt">double</span> dt);</a></code></pre></div>
<p>Corresponding to the <strong>R</strong> function <code>rgammawn</code>, this C function draws a single random increment of a gamma white-noise process. This will have expectation equal to <code>dt</code> and variance <code>sigma^2*dt</code>.</p>
<p>In particular, when <code>dW = rgammawn(sigma,dt);</code> is executed, <code>mu*dW/dt</code> is a candidate for a random rate process within an Euler-multinomial context, i.e., <code>mu*dW</code> will have expectation <code>mu*dt</code> and variance <code>mu*sigma^2*dt</code>.</p>
</div>
</div>
<div id="splines" class="section level2">
<h2>Splines</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">void</span> bspline_eval(<span class="dt">double</span> *y, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">int</span> nx, <span class="dt">int</span> i,</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">int</span> degree, <span class="dt">int</span> deriv, <span class="dt">const</span> <span class="dt">double</span> *knots);</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="dt">void</span> periodic_bspline_basis_eval(<span class="dt">double</span> x, <span class="dt">double</span> period, <span class="dt">int</span> degree,</a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="dt">int</span> nbasis, <span class="dt">double</span> *y);</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="dt">void</span> periodic_bspline_basis_eval_deriv(<span class="dt">double</span> x, <span class="dt">double</span> period,</a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="dt">int</span> degree, <span class="dt">int</span> nbasis, <span class="dt">int</span> deriv, <span class="dt">double</span> *y);</a></code></pre></div>
<p>These functions work with ordinary and periodic B-spline basis functions. For ordinary splines, one passes the spline knots in <code>knots</code>, together with the degree (<code>degree</code>) and order of derivative (<code>deriv</code>) desired. Then the value of the (order-<code>deriv</code> derivative of) the <code>i</code>-th spline at each of the values in <code>x</code> (an array of length <code>nx</code>) are passed into the array pointed to by <code>y</code>.</p>
<p>For periodic splines, the period and smoothness of the functions are given by <code>period</code> and <code>degree</code>, respectively. The fundamental domain is always assumed to be <span class="math inline">\([0,T]\)</span>, where <span class="math inline">\(T=\)</span><code>period</code>. The first function evaluates <code>nbasis</code> periodic B-spline basis functions at <code>x</code>. The second evaluates the order-<code>deriv</code> derivative of each basis function.</p>
</div>
<div id="transformations" class="section level2">
<h2>Transformations</h2>
<div id="logit-transformation" class="section level3">
<h3>Logit transformation</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">double</span> logit(<span class="dt">double</span> p);</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">double</span> expit(<span class="dt">double</span> x);</a></code></pre></div>
<p>The logit transformation is defined by <span class="math display">\[x = \log\frac{p}{1-p}.\]</span> Its inverse is therefore <span class="math display">\[p = \frac{1}{1+e^{-x}}.\]</span></p>
</div>
<div id="log-barycentric-transformation" class="section level3">
<h3>Log-barycentric transformation</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">void</span> to_log_barycentric(<span class="dt">double</span> *xt, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">int</span> n);</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="dt">void</span> from_log_barycentric(<span class="dt">double</span> *xt, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">int</span> n);</a></code></pre></div>
<p>The log-barycentric transformation takes a vector <span class="math inline">\(X_i\in\mathbb{R}^n_+\)</span>, <span class="math inline">\(i=1,\dots,n\)</span>, to a vector <span class="math inline">\(Y_i\in\mathbb{R}^n\)</span>, where <span class="math display">\[Y_i = \log\frac{X_i}{\sum_j\!X_j}.\]</span> The log-barycentric transformation takes every simplex defined by <span class="math inline">\(\sum_i\!X_i = c\)</span>, <span class="math inline">\(c\)</span> constant, to <span class="math inline">\(n\)</span>-dimensional Euclidean space <span class="math inline">\(\mathbb{R}^n\)</span>.</p>
<p>The pseudo-inverse transformation takes <span class="math inline">\(\mathbb{R}^n\)</span> to the unit simplex <span class="math inline">\(S=\{X\in\mathbb{R}^n_+\;\vert\;\sum_i\!X_i=1\}\)</span>. Specifically, <span class="math display">\[X_i = \frac{e^{Y_i}}{\sum_j\!e^{Y_j}}.\]</span></p>
<p>Note that if <span class="math inline">\(T:\mathbb{R}^n_+\to\mathbb{R}^n\)</span> is the log-barycentric transformation so defined, <span class="math inline">\(U\)</span> is the pseudo-inverse, and <span class="math inline">\(Id\)</span> denotes the identity map, then <span class="math inline">\(T\circ U=Id:\mathbb{R}^n\to\mathbb{R}^n\)</span> but <span class="math inline">\(U\circ T\ne Id\)</span>. However, if <span class="math inline">\(T\)</span> is restricted to the unit simplex, then <span class="math inline">\(U\circ T=Id:S\to S\)</span>.</p>
<p>Input:</p>
<ul>
<li><code>x</code> is a pointer to vector of parameters to be tranformed either to or from log barycentric coordinates.</li>
<li><code>n</code> is the length of this vector.</li>
<li><code>xt</code> is a pointer to the vector that will hold the results.</li>
</ul>
<p>On return, <code>xt[0]</code>, …, <code>xt[n-1]</code> will contain the transformed coordinates.</p>
</div>
</div>
<div id="convenience-functions" class="section level2">
<h2>Convenience functions</h2>
<div id="vector-dot-product" class="section level3">
<h3>Vector dot product</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">double</span> dot_product(<span class="dt">int</span> n, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *y);</a></code></pre></div>
<p>The return value is the dot (inner) product of the <code>n</code>-vectors <code>x</code> and <code>y</code>. By definition, <span class="math display">\[x{\cdot}y = \sum_i\!x_i\,y_i.\]</span></p>
</div>
<div id="exponentialgeometric-rate-conversion" class="section level3">
<h3>Exponential/geometric rate conversion</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">double</span> exp2geom_rate_correction(<span class="dt">double</span> R, <span class="dt">double</span> dt);</a></code></pre></div>
<p>This function computes <span class="math inline">\(r\)</span> such that if <span class="math display">\[N \sim \mathrm{Geometric}\left(p=1-e^{-r\,{\Delta}t}\right)\]</span> and <span class="math display">\[T \sim \mathrm{Exponential}\left(\mathrm{rate}=R\right),\]</span> then <span class="math inline">\(\mathbb{E}\left[N\,{\Delta}t\right] = \mathbb{E}\left[T\right]\)</span>. That is, <span class="math inline">\(r\)</span> is the rate for an Euler process that gives the same expected waiting time as the exponential process it approximates. In particular <span class="math inline">\(r \to R\)</span> as <span class="math inline">\({\Delta}t \to 0\)</span>.</p>
</div>
</div>
<div id="access-to-the-userdata" class="section level2">
<h2>Access to the userdata</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">const</span> <span class="dt">int</span> *get_userdata_int(<span class="dt">const</span> <span class="dt">char</span> *name);</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="dt">const</span> <span class="dt">double</span> *get_userdata_double(<span class="dt">const</span> <span class="dt">char</span> *name);</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="dt">const</span> SEXP get_userdata(<span class="dt">const</span> <span class="dt">char</span> *name);</a></code></pre></div>
<p>The first function returns a pointer to the integer element of the <code>userdata</code> with the given <code>name</code>. The second retrieves a pointer to a double-precision element of <code>userdata</code> by name. The third form returns a general S expression (<code>SEXP</code>). See <a href="https://kingaa.github.io/manuals/pomp/html/userdata.html"><code>?userdata</code></a> for more information.</p>
</div>
<div id="prototypes-for-basic-model-components" class="section level2">
<h2>Prototypes for basic model components</h2>
<p><strong>pomp</strong> provides a facility whereby model codes can be compiled into a dynamically linked library for use in pomp objects. Specifically, basic model components are coded as C functions with the following prototypes.</p>
<p><strong>NB:</strong> These functions should not be used within C snippets!</p>
<div id="indices" class="section level3">
<h3>Indices</h3>
<p>Each of the following functions is supplied one or more of the <code>stateindex</code>, <code>parindex</code>, <code>covindex</code>, <code>obsindex</code>, <code>vmatindex</code> arguments. Each of these is an integer vector: the integers within are indices giving the positions of specific model variables, according to the user’s specification, the latter being given by means of the <code>statenames</code>, <code>paramnames</code>, <code>covarnames</code>, and <code>obsnames</code> arguments. See <a href="https://kingaa.github.io/manuals/pomp/html/pomp.html"><code>?pomp</code></a> for more explanation. Thus, for example, within the body of a function of prototype <code>pomp_rinit</code> (see below),</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"> x[stateindex[<span class="dv">0</span>]];</a>
<a class="sourceLine" id="cb12-2" title="2"> x[stateindex[<span class="dv">3</span>]];</a>
<a class="sourceLine" id="cb12-3" title="3"> p[parindex[<span class="dv">2</span>]];</a>
<a class="sourceLine" id="cb12-4" title="4"> covars[covindex[<span class="dv">1</span>]];</a></code></pre></div>
<p>refer to the first state variable, the fourth state variable, the third parameter, and the second covariate, respectively.</p>
</div>
<div id="rinit" class="section level3">
<h3>rinit</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">void</span> pomp_rinit(<span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p, <span class="dt">double</span> t,</a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="dt">const</span> <span class="dt">double</span> *covars);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>p</code> is a pointer to parameter vector.</li>
<li><code>t</code> is the current time.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is a pointer to a vector containing the (possibly interpolated) values of the covariates at the current time.</li>
<li><code>x</code> is a vector that will, on return, contain a draw from the initial-state distribution.</li>
</ul>
<p><strong>NB:</strong> There is no need to call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="rprocess" class="section level3">
<h3>rprocess</h3>
<div id="step.fun-as-used-by-euler-and-onestep" class="section level4">
<h4><code>step.fun</code> as used by <code>euler</code> and <code>onestep</code></h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">void</span> pomp_onestep_sim(<span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p,</a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="dt">const</span> <span class="dt">double</span> *covars, <span class="dt">double</span> t, <span class="dt">double</span> dt);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of covariates.</li>
<li><code>t</code> is the time at the beginning of the step.</li>
<li><code>dt</code> is the step size (duration of the interval).</li>
<li><code>x</code> is the vector, that will, on return, contain a draw from the state process at time <code>t</code>+<code>dt</code>.</li>
</ul>
<p><strong>NB:</strong> There is no need to call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="rate.fun-as-used-by-gillespie" class="section level4">
<h4><code>rate.fun</code> as used by <code>gillespie</code></h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">double</span> pomp_ssa_rate_fn(<span class="dt">int</span> event, </a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">double</span> t, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p,</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex, </a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="dt">const</span> <span class="dt">double</span> *covars);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>event</code> is an integer specifying the number of the reaction whose rate is desired (the first is event is 1, not 0).</li>
<li><code>t</code> is the current time.</li>
<li><code>x</code> is the vector of state variables.</li>
<li><code>p</code> is the vector of parameters.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
</ul>
<p>The function returns the rate of the requested reaction.</p>
</div>
</div>
<div id="dprocess" class="section level3">
<h3>dprocess</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="dt">void</span> pomp_onestep_pdf(<span class="dt">double</span> *loglik,</a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="dt">const</span> <span class="dt">double</span> *x1, <span class="dt">const</span> <span class="dt">double</span> *x2, <span class="dt">double</span> t1, <span class="dt">double</span> t2, <span class="dt">const</span> <span class="dt">double</span> *p,</a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="dt">const</span> <span class="dt">double</span> *covars);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>t1</code>, <code>t2</code> are the times at the beginning and end of the interval, respectively.</li>
<li><code>x1</code>, <code>x2</code> are the state vectors at time <code>t1</code> and <code>t2</code>, respectively.</li>
<li><code>p</code> is the parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>loglik</code> is a pointer to the scalar that will, on return, contain the log probability density.</li>
</ul>
</div>
<div id="skeleton" class="section level3">
<h3>skeleton</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">void</span> pomp_skeleton(<span class="dt">double</span> *f, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p,</a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="dt">const</span> <span class="dt">double</span> *covars, <span class="dt">double</span> t);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>t</code> is the time.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>f</code> is a vector, of the same length as <code>x</code>, that will, on return, contain the value of the map or vectorfield.</li>
</ul>
</div>
<div id="rmeasure" class="section level3">
<h3>rmeasure</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="dt">void</span> pomp_measure_model_simulator(<span class="dt">double</span> *y, </a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p,</a>
<a class="sourceLine" id="cb18-3" title="3">  <span class="dt">const</span> <span class="dt">int</span> *obsindex, <span class="dt">const</span> <span class="dt">int</span> *stateindex,</a>
<a class="sourceLine" id="cb18-4" title="4">  <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb18-5" title="5">  <span class="dt">const</span> <span class="dt">double</span> *covars, <span class="dt">double</span> t);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>t</code> is the time at the beginning of the Euler step.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter vector.</li>
<li><code>obsindex</code>, <code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>y</code> is a vector that will, on return, contain the simulated observations.</li>
</ul>
<p><strong>NB:</strong> There is no need to call <code>GetRNGstate()</code> or <code>PutRNGstate()</code> in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="dmeasure" class="section level3">
<h3>dmeasure</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">void</span> pomp_measure_model_density(<span class="dt">double</span> *lik, </a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="dt">const</span> <span class="dt">double</span> *y, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p, <span class="dt">int</span> give_log,</a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="dt">const</span> <span class="dt">int</span> *obsindex, <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="dt">const</span> <span class="dt">double</span> *covars, <span class="dt">double</span> t);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>y</code> is the vector of observables at time <code>t</code>.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter vector.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if log probability is desired;</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
<li><code>obsindex</code>, <code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>lik</code> is a pointer to a scalar that will, on return, contain the requested likelihood or log likelihood.</li>
</ul>
</div>
<div id="emeasure" class="section level3">
<h3>emeasure</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="dt">void</span> pomp_measure_model_expectation (<span class="dt">double</span> *e, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p,</a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="dt">const</span> <span class="dt">int</span> *obsindex, <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb20-3" title="3">  <span class="dt">const</span> <span class="dt">double</span> *covars, <span class="dt">double</span> t);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>t</code> is the time.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>e</code> is a vector, of the same length as <code>x</code>, that will, on return, contain the expected value of the observed variables.</li>
</ul>
</div>
<div id="vmeasure" class="section level3">
<h3>vmeasure</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">void</span> pomp_measure_model_covariance (<span class="dt">double</span> *v, <span class="dt">const</span> <span class="dt">double</span> *x, <span class="dt">const</span> <span class="dt">double</span> *p,</a>
<a class="sourceLine" id="cb21-2" title="2">  <span class="dt">const</span> <span class="dt">int</span> *vmatindex, <span class="dt">const</span> <span class="dt">int</span> *stateindex, <span class="dt">const</span> <span class="dt">int</span> *parindex, <span class="dt">const</span> <span class="dt">int</span> *covindex,</a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="dt">const</span> <span class="dt">double</span> *covars, <span class="dt">double</span> t);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>t</code> is the time.</li>
<li><code>x</code> is the state vector at time <code>t</code>.</li>
<li><code>p</code> is the parameter parameter vector.</li>
<li><code>stateindex</code>, <code>parindex</code>, <code>covindex</code>, <code>vmatindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>covars</code> is the vector of (possibly interpolated) covariates at time <code>t</code>.</li>
<li><code>v</code> points to a square matrix that will, on return, contain the covariance matrix of the observed variables. In particular, if <span class="math inline">\(X\)</span> is the latent state and the <code>nobs</code> observables are <span class="math inline">\(Y_i\)</span>, then <code>v[vmatindex[i+nobs*j]]</code> contains <span class="math inline">\(\mathrm{Cov}[Y_i,Y_j\;\vert\;X]\)</span>.</li>
<li>It is the user’s responsibility to ensure that the returned covariance matrix is symmetric: this is not checked.</li>
</ul>
</div>
<div id="rprior" class="section level3">
<h3>rprior</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">void</span> pomp_rprior(<span class="dt">double</span> *p, <span class="dt">const</span> <span class="dt">int</span> *parindex);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>parindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
</ul>
<p>On return, <code>p</code> will contain a new random draw from the prior distribution.</p>
<p><strong>NB:</strong> There is no need to call GetRNGstate() or PutRNGstate() in the body of the user-defined function. The RNG is initialized before any call to this function, and the RNG state is written afterward. Inclusion of these calls in the user-defined function may result in significant slowdown.</p>
</div>
<div id="dprior" class="section level3">
<h3>dprior</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">void</span> pomp_dprior(<span class="dt">double</span> *lik, <span class="dt">const</span> <span class="dt">double</span> *p, <span class="dt">int</span> give_log, <span class="dt">const</span> <span class="dt">int</span> *parindex);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>give_log</code> is an integer:
<ul>
<li><code>give_log=1</code> if log probability is desired;</li>
<li><code>give_log=0</code> if probability is desired.</li>
</ul></li>
<li><code>parindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>lik</code> is a pointer to a scalar that will, on return, contain the requested probability density or log probability density.</li>
</ul>
</div>
<div id="partrans" class="section level3">
<h3>partrans</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">void</span> pomp_transform_fn(<span class="dt">double</span> *pt, <span class="dt">const</span> <span class="dt">double</span> *p, <span class="dt">const</span> <span class="dt">int</span> *parindex);</a></code></pre></div>
<p>Description:</p>
<ul>
<li><code>p</code> is the parameter vector.</li>
<li><code>parindex</code>: see <a href="#indices"><strong>Indices</strong></a>, above.</li>
<li><code>pt</code> is the vector wherein the results will be returned.</li>
</ul>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
