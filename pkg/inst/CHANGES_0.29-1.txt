There are three main changes in version 0.29-1.

1. Substantial improvements to the documentation, including both the vignettes and the manual pages.

2. A bigger, more intuitive, and easier-to-use set of "plugins" for filling the 'rprocess' slot of a 'pomp' object.

3. Changes to the C interface for 'rmeasure' and 'dmeasure' functions.

The first and second changes preserve backward compatibility: your old codes will work fine even if you do not make use of the new functionality. Using the old-style plugins 'euler.simulate' or 'onestep.simulate' will result in annoying warnings about these functions being deprecated and suggesting that you migrate to the new-style plugins sometime soon. In a future release of pomp, 'euler.simulate' and 'onestep.simulate' will disappear. 

The third change does NOT preserve backward compatibility. If you use compiled native routines for 'rmeasure' and/or 'dmeasure', you must modify those routines or your codes will not work properly (and will almost certainly crash) when used with versions 0.29-1 and later of pomp. The required modification is quite minor, however, and is detailed below.

In more detail:

Change 1. 
The vignettes have been completely rewritten to be useful as tutorials. The first vignette, "intro_to_pomp", is a step-by-step guide to the construction of a 'pomp' and simulation, particle filtering, trajectory-matching, iterated filtering, and nonlinear forecasting. View it by doing
R> ?vignette("intro_to_pomp")
The second vignette shows how to accelerate performance using compiled native routines and briefly introduces the developer interface to pomp.  View it by doing
R> ?vignette("advanced_topics_in_pomp")

Change 2. New plugins.
As you probably know very well, it can be challenging to implement a model in pomp.  In particular, the most difficult bit is typically writing the process model simulator (rprocess).  In an effort to make this more intuitive, I have provided several new "plugins": functions that write the 'rprocess' function for you given minimal input on the form of the model.

For some time there has been some plugin functionality, but their structure has made them nonintuitive and their documentation difficult to understand from the user's point of view. The new plugins are much more straightforward to use and their documentation is clearer (I hope). The new plugins provide precisely the same functionality: only the interface has changed. To be clear: switching over to the new-style plugins will have no effect on the underlying model nor, therefore, on inferences that have been based on that model.  

If you have been using the old-style plugins (euler.simulate or onestep.simulate), you can continue to do so for the time being. However, warning messages will be generated to inform you that these functions are deprecated and will be removed in a later release of pomp.  

To switch over to the new-style plugins, you need only edit a few lines in the R code that constructs a pomp object.  Specifically, if you use

pomp(...,rprocess=euler.simulate,...,delta.t=dt,...,step.fun=foo,...,PACKAGE=bar,...)

where 'foo' is either an R function or the name of a compiled native routine, and 'bar' is the name of the shared-object library where the compiled native routine resides, you can achieve the same functionality by using

pomp(...,rprocess=euler.sim(step.fun=foo,delta.t=dt,PACKAGE=bar),...)

Similarly, if you use 

pomp(...,rprocess=onestep.simulate,...,step.fun=foo,...,PACKAGE=bar,...)

replace it with

pomp(...,rprocess=onestep.sim(step.fun=foo,PACKAGE=bar),...)

Essentially, the new-style plugins are functions that return "customized" functions suitable for use in the 'rprocess' slot of a 'pomp' object.

There are now new plugins that include a discrete-time model plugin ('discrete.time.sim') and an implementation of the Gillespie algorithm ('gillespie.sim'). The FORTRAN codes that underly 'gillespie.sim' are due to Helen Wearing.  For documentation on the new functionality, see
R> ?plugins
or 
R>?euler.sim
R>?gillespie.sim
R>?onestep.sim
R>?discrete.time.sim

Change 3. New interface for C versions of 'rmeasure' and 'dmeasure'.

This change only affects you if you use compiled native routines for the measurement portion of your model.  If you specify your measurement model either using 'measurement.model=blah' or by specifying 'rmeasure' and/or 'dmeasure' as R functions, you need do nothing.

If you have written C functions to implement your measurement model, you have written a C function of prototype

void pomp_measure_model_simulator (double *y, double *x, double *p, int *stateindex, int *parindex, int *covindex, int ncovars, double *covars, double t);

and/or a function of prototype

void pomp_measure_model_density (double *lik, double *y, double *x, double *p, int give_log, int *stateindex, int *parindex, int *covindex, int ncovars, double *covars, double t);

In the new version of 'pomp', you must modify these functions to have prototypes

void pomp_measure_model_simulator (double *y, double *x, double *p, int *obsindex, int *stateindex, int *parindex, int *covindex, int ncovars, double *covars, double t);

and

void pomp_measure_model_density (double *lik, double *y, double *x, double *p, int give_log, int *obsindex, int *stateindex, int *parindex, int *covindex, int ncovars, double *covars, double t);

The only difference is that you need to insert a new int* argument 'obsindex' in the appropriate place.

If you simply insert the new argument and do nothing more, your codes should function as before. If you wish to take advantage of the new functionality, it should make your codes more robust. To do so, when constructing a 'pomp' object, specify the names of observed variables in the 'obsnames' argument to 'pomp'. If you have done this, upon any call to either your C 'dmeasure' or 'rmeasure' function, 'obsindex' will be a pointer to a set of integers that indicate the positions in 'y' that correspond to the variables in 'obsnames' in that order. Thus, 'obsindex' is exactly analogous to 'stateindex', 'parindex', and 'covindex': 'obsindex' is to 'y' as 'stateindex' is to 'x' as 'parindex' is to 'p' as 'covindex' is to 'covars'.

Here is an example of one of my own codes.  Before version 0.29-1, the code was:
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#define TAU          (p[parindex[0]])
#define DEATHS       (x[stateindex[4]])
#define DATADEATHS   (y[0])

void norm_rmeasure (double *y, double *x, double *p, 
		    int *stateindex, int *parindex, int *covindex,
		    int ncovars, double *covars, double t)
{
  double v, tol = 1.0e-18;
  v = DEATHS*exp(TAU);
  if (!(R_FINITE(v))) {
    DATADEATHS = R_NaReal;
  } else {
    DATADEATHS = rnorm(DEATHS,v+tol);
  }
}

void norm_dmeasure (double *lik, double *y, double *x, double *p, int give_log,
		    int *stateindex, int *parindex, int *covindex,
		    int ncovars, double *covars, double t)
{
  double v, tol = 1.0e-18;
  v = DEATHS*exp(TAU);
  if (!(R_FINITE(v))) {
    *lik = tol;
  } else {
    *lik = dnorm(DATADEATHS,DEATHS,v+tol,0)+tol;
  }
  if (give_log) *lik = log(*lik);
}

#undef TAU
#undef DEATHS
#undef DATADEATHS
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

As of pomp version 0.29-1, the code is:
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
#define TAU          (p[parindex[0]])
#define DEATHS       (x[stateindex[4]])
#define DATADEATHS   (y[obsindex[0]])

void norm_rmeasure (double *y, double *x, double *p, 
		    int *obsindex, int *stateindex, int *parindex, int *covindex,
		    int ncovars, double *covars, double t)
{
  double v, tol = 1.0e-18;
  v = DEATHS*exp(TAU);
  if (!(R_FINITE(v))) {
    DATADEATHS = R_NaReal;
  } else {
    DATADEATHS = rnorm(DEATHS,v+tol);
  }
}

void norm_dmeasure (double *lik, double *y, double *x, double *p, int give_log,
		    int *obsindex, int *stateindex, int *parindex, int *covindex,
		    int ncovars, double *covars, double t)
{
  double v, tol = 1.0e-18;
  v = DEATHS*exp(TAU);
  if (!(R_FINITE(v))) {
    *lik = tol;
  } else {
    *lik = dnorm(DATADEATHS,DEATHS,v+tol,0)+tol;
  }
  if (give_log) *lik = log(*lik);
}

#undef TAU
#undef DEATHS
#undef DATADEATHS
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

A diff on these two shows just the changes:
ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd
3c3
< #define DATADEATHS   (y[0])
---
> #define DATADEATHS   (y[obsindex[0]])
6c6
<                   int *stateindex, int *parindex, int *covindex,
---
>                   int *obsindex, int *stateindex, int *parindex, int *covindex,
19c19
<                   int *stateindex, int *parindex, int *covindex,
---
>                   int *obsindex, int *stateindex, int *parindex, int *covindex,
ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd